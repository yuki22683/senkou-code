{
  "cpp_lesson1_ex1_slide1_title": "C++（シープラスプラス）とは？",
  "cpp_lesson1_ex1_slide1_content": "# パワフルで高速な言語（げんご）\\n\\nC++（シープラスプラス）は、C言語を元にしてさらに便利な機能を追加した言語です。\\n\\n**身近な例え：**\\nC言語が「普通の車」だとしたら、C++は「スーパーカー」のような存在です！速さはそのままに、もっと便利な機能がついています。\\n\\n**どんなところで使われているの？**\\n- ゲーム（速さが命！）\\n- ブラウザ（ChromeやFirefoxなど）\\n- 3DCGソフト\\n\\nなど、**スピードが求められる場所**で大活躍しています。",
  "cpp_lesson1_ex1_slide2_title": "C++への入り口",
  "cpp_lesson1_ex1_slide2_content": "# std::cout（シーアウト）を使おう\\n\\nC++で画面に文字を出すには、`std::cout`（スタンダード・シーアウト）を使います。\\n`cout` は「Character OUTput」（文字を出力）の略です。\\n\\n`<<` という矢印のような記号を使って、文字を画面の方へ送ります。\\n\\n**イメージ：**\\n画面 `<<` \\\"こんにちは\\\"\\n（文字が矢印の方向に流れていくイメージ！）\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n#include <iostream>  // 入出力を使う準備\\nint main() {\\n    std::cout << \\\"C++最高！\\\" << std::endl;\\n    return 0;\\n}\\n```\\n\\n**用語解説：**\\n- `std::endl`（エンドエル）: 改行して次の行に進む\\n- `#include <iostream>`: 入出力機能を使えるようにする",
  "cpp_lesson1_ex2_slide1_title": "変数（へんすう）とは？",
  "cpp_lesson1_ex2_slide1_content": "# データを保存する「はこ」\\n\\nプログラムの中で数字や文字に名前をつけて、あとで使いやすくするための仕組みが **変数（へんすう）** です。\\n\\n**身近な例え：**\\nおもちゃ箱に「レゴ入れ」「ぬいぐるみ入れ」とラベルを貼るように、プログラムでも「はこ」に名前をつけてデータをしまっておきます。\\n\\n例えば、年齢を覚えておきたいなら `age` という名前の「はこ」を作ります。",
  "cpp_lesson1_ex2_slide2_title": "数字のラベル int",
  "cpp_lesson1_ex2_slide2_content": "# 整数（せいすう）のラベル\\n\\n数字（1, 2, 3 のような整数）を入れたいときは、`int`（イント）というラベルを貼ります。\\n`int` は「Integer」（整数）の略です。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nint age = 20;  // 「age」という名前のはこに20を入れる\\nstd::cout << age << std::endl;  // ageの中身を表示\\n```\\n=> 20 と表示されます\\n\\n**C言語との違い：**\\nC言語では `printf(\\\"%d\\\", age)` と書いていましたが、C++では `std::cout << age` とシンプルに書けます！",
  "cpp_lesson1_ex3_slide1_title": "計算はコンピュータにお任せ",
  "cpp_lesson1_ex3_slide1_content": "# 高速な計算処理\\n\\nコンピュータは人間よりもずっと速く計算できます。\\nどんなに大きな数字でも、プログラミングで指示を出せば一瞬で解いてくれます。",
  "cpp_lesson1_ex3_slide2_title": "計算の記号",
  "cpp_lesson1_ex3_slide2_content": "# 矢印で送ろう\\n\\n`<<` で繋ぐことで、計算した結果をそのまま画面に出すことができます。\\n\\n**コード例：**\\n```cpp\\nint cookies = 10;\\nint friends = 2;\\n// クッキー ÷ 友達 の結果を画面へ！\\nstd::cout << cookies / friends << std::endl;\\n```\\n=> 5",
  "cpp_lesson1_ex4_slide1_title": "あまりを求める",
  "cpp_lesson1_ex4_slide1_content": "# 割り算の「あまり」を知りたい！\\n\\n割り算をしたときに、割り切れなくて「あまり」が出ることがありますよね。\\n`%` という記号を使うと、その **あまり** だけを計算してくれます。\\nこれを「剰余（じょうよ）」と呼びます。",
  "cpp_lesson1_ex4_slide2_title": "% の使い方",
  "cpp_lesson1_ex4_slide2_content": "# あまりを計算\\n\\n```cpp\\nstd::cout << 10 % 3 << std::endl;  // => 1\\n```\\n10 ÷ 3 は 3 あまり 1 なので、「1」が表示されます。\\n\\n```cpp\\nstd::cout << 8 % 2 << std::endl;   // => 0\\n```\\n8 ÷ 2 は 4 あまり 0 なので、「0」になります（割り切れるということです！）",
  "cpp_lesson1_ex5_slide1_title": "中身を増やしたいとき",
  "cpp_lesson1_ex5_slide1_content": "# はこの中身をパワーアップ\\n\\n「今の点数に10点プラスしたい！」というとき、`+=` を使うと便利です。\\nこれは「今の数字に足して、そのまま保存する」という合体技です。\\n\\n```cpp\\nint x = 10;\\nx += 5;  // x に 5 を足して保存\\nstd::cout << x << std::endl;  // => 15\\n```",
  "cpp_lesson1_ex5_slide2_title": "-= も使える",
  "cpp_lesson1_ex5_slide2_content": "# 引き算バージョン\\n\\n`-=` を使えば、「今の数字から引いて保存」ができます。\\n\\n```cpp\\nint x = 10;\\nx -= 3;  // x から 3 を引いて保存\\nstd::cout << x << std::endl;  // => 7\\n```",
  "cpp_lesson1_ex6_slide1_title": "連結（れんけつ）とは？",
  "cpp_lesson1_ex6_slide1_content": "# 情報を組み合わせて表示する\\n\\n文章の途中に、変数（はこ）の中身を流し込んで一つのメッセージにすることを **連結** と呼びます。\\nC++では `<<` を使って、電車のように情報を連結して画面へ送ります。",
  "cpp_lesson1_ex6_slide2_title": "<< でつなげましょう",
  "cpp_lesson1_ex6_slide2_content": "# ガチャンと連結！\\n\\n`<<` を何回も使うことで、文字やはこの中身をどんどん繋げることができます。\\n\\n**コード例：**\\n```cpp\\nint hour = 15;\\nstd::cout << \\\"今は \\\" << hour << \\\" 時です\\\" << std::endl;\\n```\\n=> 今は 15 時です",
  "cpp_lesson1_ex7_slide1_title": "動的配列（どうてきはいれつ）とは？",
  "cpp_lesson1_ex7_slide1_content": "# 長さが変わる便利な列\\n\\nあとから中身を増やしたり減らしたりできる「はこ」の列を **動的配列（どうてきはいれつ）** と呼びます。\\n\\n**身近な例え：**\\n普通の配列は「決まった数のロッカー」ですが、`vector` は「必要に応じて増やせるロッカー」のようなものです。\\n\\n「伸び縮みする魔法（まほう）の配列」みたいなものです。\\nC++では `vector`（ベクター）という機能を使ってこれを作ります。",
  "cpp_lesson1_ex7_slide2_title": "std::vector",
  "cpp_lesson1_ex7_slide2_content": "# 書き方のルール\\n\\n`< >` の中に「何を入れるか」を指定します。\\n- `<int>`: 整数を入れる\\n- `<std::string>`: 文字列を入れる\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n#include <vector>  // vectorを使う準備\\n\\n// 文字列を入れる vector を作る\\nstd::vector<std::string> items = {\\\"Apple\\\", \\\"Orange\\",
  "cpp_lesson1_ex8_slide1_title": "条件分岐（じょうけんぶんき）とは？",
  "cpp_lesson1_ex8_slide1_content": "# プログラムに判断させてみよう\\n\\n「雨が降ったら傘をさす」「晴れたら外で遊ぶ」\\nこんなふうに、状況によって動きを変えることを **条件分岐（じょうけんぶんき）** と呼びます。\\nプログラムに「もし〜なら、これをしてね」と教えてあげましょう。",
  "cpp_lesson1_ex8_slide2_title": "if文",
  "cpp_lesson1_ex8_slide2_content": "# ( ) と { } を使いましょう\\n\\nC++でも、`if (条件)` のあとに `{ }` を入力して、その中にやりたいことを入力します。\\n\\n**コード例：**\\n```cpp\\nint temp = 30;\\nif (temp > 25) {\\n    std::cout << \\\"暑いですね\\\" << std::endl;\\n}\\n```",
  "cpp_lesson1_ex9_slide1_title": "それ以外の場合は？",
  "cpp_lesson1_ex9_slide1_content": "# else（エルス）の役割\\n\\n条件に当てはまらなかったときの別のルートを作るのが **else（エルス）** です。「もし〜なら」とセットで使うことで、プログラムのルートを2つに分けることができます。",
  "cpp_lesson1_ex9_slide2_title": "elseブロック",
  "cpp_lesson1_ex9_slide2_content": "# どちらかを選びます\\n\\n条件に当てはまらないときの動きは `else` を使って入力します。\\n\\n**コード例 ：**\\n```cpp\\nint age = 15;\\nif (age >= 20) {\\n    std::cout << \\\"大人\\\" << std::endl;\\n} else {\\n    std::cout << \\\"子供\\\" << std::endl;\\n}\\n```",
  "cpp_lesson1_ex10_slide1_title": "条件を組み合わせる",
  "cpp_lesson1_ex10_slide1_content": "# もっと細かい条件で\\n\\n「10歳以上、かつ、20歳未満」のように、2つの条件を両方クリアしているかチェックしたいときがあります。\\nそんなときは `&&` （アンド）を使います。\\n逆に「どちらか片方でもOK」なら `||` （オア）を使います。",
  "cpp_lesson1_ex10_slide2_title": "&& と || の使い方",
  "cpp_lesson1_ex10_slide2_content": "# 条件の合体技\\n\\n```cpp\\nint age = 15;\\nif (age >= 10 && age < 20) {\\n    std::cout << \\\"10代です\\\" << std::endl;\\n}\\n```\\n\\n`&&` は「かつ」、`||` は「または」の意味です。",
  "cpp_lesson1_ex11_slide1_title": "繰り返し（ループ）とは？",
  "cpp_lesson1_ex11_slide1_content": "# 自動で順番に処理する\\n\\n同じ作業を何度も繰り返すための仕組みが **ループ（繰り返し）** です。\\n\\n**身近な例え：**\\n学校で出席をとるとき、「田中さん」「鈴木さん」「佐藤さん」...と一人ずつ名前を呼びますよね。ループはこの「順番に全員をチェック」する作業を自動でやってくれます。\\n\\n配列の中身を一つずつ順番に全部チェックしたいときなどに非常に役立ちます。",
  "cpp_lesson1_ex11_slide2_title": "範囲for文",
  "cpp_lesson1_ex11_slide2_content": "# for (変数 : コンテナ)\\n\\nC++には **範囲for文（はんいフォーぶん）** という便利なループがあります。\\n「はこ（配列）」の中に入っているものを、最初から最後まで順番に取り出せます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nstd::vector<std::string> fruits = {\\\"Apple\\\", \\\"Banana\\",
  "cpp_lesson1_ex12_slide1_title": "辞書（じしょ）とは？",
  "cpp_lesson1_ex12_slide1_content": "# キーワードで検索（けんさく）！\\n\\n「名前」と「データ」をセットにして保存できるのが **辞書（map＝マップ）** です。\\n\\n**身近な例え：**\\n国語辞典（こくごじてん）を想像してください。「りんご」という言葉を調べると、その意味が出てきますよね。\\n\\n`map` も同じで、「キー（名前）」を指定すると、それに対応する「値（データ）」が取り出せます。\\n\\nキーワードを使って目的のデータをすぐに見つけられる、とても便利な仕組みです！",
  "cpp_lesson1_ex13_slide1_title": "関数（かんすう）とは？",
  "cpp_lesson1_ex13_slide1_content": "# オリジナルの技を作ろう\\n\\n何度も使う手順をまとめて名前をつけたものを **関数（かんすう）** と呼びます。\\n\\n**身近な例え：**\\n「朝の準備」という言葉を聞くと、「起きる→顔を洗う→着替える→ご飯を食べる」という一連の動作を思い浮かべますよね。\\n\\n関数も同じです！「sayHello」と呼ぶだけで、中に書いた処理を全部やってくれます。\\n\\n一度作れば、「アレやって！」と名前を呼ぶだけで何度でも実行できる、便利なショートカットのようなものです。",
  "cpp_lesson1_ex13_slide2_title": "手順をまとめる",
  "cpp_lesson1_ex13_slide2_content": "# 関数の定義（ていぎ）\\n\\nやりたいことをひとまとめにして、名前をつけることができます。\\n一度作っておけば、呼び出すだけでいつでも動かせます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// 「sayHello」という関数を作る（定義する）\\nvoid sayHello() {\\n    std::cout << \\\"ハロー！\\\" << std::endl;\\n}\\n\\n// mainの中で呼び出し（使う）\\nsayHello();  // これで「ハロー！」と表示される\\n```\\n\\n**用語解説：**\\n- `void`（ボイド）: 「何も返さない」という意味\\n- `()`: 関数名のあとに必ずつける丸かっこ\\n- `{}`: この中に実行したい処理を書く",
  "cpp_lesson2_ex1_slide1_title": "クラスとは？",
  "cpp_lesson2_ex1_slide1_content": "# データと機能の設計図（せっけいず）\\n\\n**クラス**は、データ（変数）と機能（関数）をひとまとめにした「設計図」です。\\n\\n**身近な例え：**\\n「犬」の設計図を考えてみましょう。\\n- データ: 名前、年齢、毛の色\\n- 機能: 吠（ほ）える、走る、食べる\\n\\nこの設計図（クラス）から、「ポチ」「タロウ」「ハチ」という実際の犬（オブジェクト）を作れます。\\n\\n設計図は1つでも、そこから何匹でも犬を作れるのがポイントです！",
  "cpp_lesson2_ex1_slide2_title": "クラスの定義",
  "cpp_lesson2_ex1_slide2_content": "# class キーワード\\n\\n`class`（クラス）を使ってクラスを定義（ていぎ）します。\\n`public:`（パブリック）の下に、外から使える部分を書きます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nclass Dog {       // Dogという設計図を作る\\npublic:           // ここから下は外から使える\\n    std::string name;  // 名前を入れる場所\\n};\\n\\n// 設計図から実際の犬を作る\\nDog d;            // dという犬を作成\\nd.name = \\\"Pochi\\\"; // 名前をつける\\n```\\n\\n**用語解説：**\\n- `public`: 公開（こうかい）という意味。外からアクセスできる\\n- `.`（ドット）: オブジェクトの中身にアクセスする記号",
  "cpp_lesson2_ex2_slide1_title": "コンストラクタとは？",
  "cpp_lesson2_ex2_slide1_content": "# 初期化（しょきか）の儀式（ぎしき）\\n\\n**コンストラクタ**は、オブジェクトを作るときに自動的に呼ばれる特別な関数です。\\n\\n**身近な例え：**\\n新しいスマホを買ったとき、最初に「言語設定」「名前登録」などの初期設定をしますよね。コンストラクタは、オブジェクトが生まれたときに自動で行われる「初期設定」のようなものです。\\n\\nオブジェクトの初期値（さいしょの値）を設定するのに使います。",
  "cpp_lesson2_ex2_slide2_title": "コンストラクタの書き方",
  "cpp_lesson2_ex2_slide2_content": "# クラス名と同じ名前\\n\\nコンストラクタには特別なルールがあります：\\n1. **クラス名と同じ名前**にする\\n2. **戻り値の型を書かない**（voidも書かない）\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nclass Box {\\npublic:\\n    int size;        // サイズを入れる場所\\n    Box(int s) {     // コンストラクタ（クラス名と同じ）\\n        size = s;    // 受け取った値で初期化\\n    }\\n};\\n\\nBox b(10);  // Boxを作ると同時にsize=10で初期化！\\n```\\n\\n**ポイント：**\\n`Box b(10)` と書くと、コンストラクタが自動で呼ばれ、size に 10 が入ります。",
  "cpp_lesson2_ex3_slide1_title": "メンバ関数とは？",
  "cpp_lesson2_ex3_slide1_content": "# クラスに属する関数\\n\\n**メンバ関数** は、クラスの中で定義される関数です。そのクラスのデータを使った処理ができます。",
  "cpp_lesson2_ex3_slide2_title": "メンバ関数の定義",
  "cpp_lesson2_ex3_slide2_content": "# クラスの中に関数を書く\\n\\nクラス定義の中に関数を書くと、そのクラスのメンバ関数になります。\\n\\n**コード例：**\\n```cpp\\nclass Circle {\\npublic:\\n    int radius;\\n    int area() {\\n        return radius * radius * 3;\\n    }\\n};\\n```",
  "cpp_lesson2_ex4_slide1_title": "参照とは？",
  "cpp_lesson2_ex4_slide1_content": "# 変数の別名\\n\\n**参照** は、既存の変数に別の名前をつける機能です。参照を通じて元の変数を操作できます。",
  "cpp_lesson2_ex4_slide2_title": "参照の使い方",
  "cpp_lesson2_ex4_slide2_content": "# & で参照を作る\\n\\n型名の後に `&` をつけると参照型になります。参照は宣言時に必ず初期化が必要です。\\n\\n**コード例：**\\n```cpp\\nint x = 10;\\nint& ref = x;  // ref は x の別名\\nref = 20;      // x も 20 になる\\n```",
  "cpp_lesson2_ex5_slide1_title": "継承（けいしょう）とは？",
  "cpp_lesson2_ex5_slide1_content": "# クラスを拡張（かくちょう）する\\n\\n**継承（けいしょう）** を使うと、既存（きそん）のクラス（親クラス）の機能を引き継いだ新しいクラス（子クラス）を作れます。\\n\\n**身近な例え：**\\n「動物」という親クラスがあるとします。\\n- 動物は「食べる」「寝る」ができる\\n\\n「犬」は動物の子クラスです。\\n- 犬は動物なので「食べる」「寝る」ができる（親から継承）\\n- さらに「吠える」という独自の機能を追加できる\\n\\n一から作り直さなくても、親の機能を受け継げるので、コードの再利用（さいりよう）に便利です！",
  "cpp_lesson2_ex5_slide2_title": "継承の書き方",
  "cpp_lesson2_ex5_slide2_content": "# : public 親クラス\\n\\n子クラス名の後に `: public 親クラス名` と書きます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// 親クラス（動物）\\nclass Animal {\\npublic:\\n    void eat() { std::cout << \\\"eating\\\" << std::endl; }\\n};\\n\\n// 子クラス（犬）- Animalを継承\\nclass Dog : public Animal {\\n    // 何も書かなくても eat() が使える！\\n};\\n\\nDog d;\\nd.eat();  // \\\"eating\\\" と表示される（親から継承した機能）\\n```\\n\\n**ポイント：**\\n子クラスは、親クラスの `public` な機能を自動的に使えるようになります。",
  "cpp_lesson2_ex6_slide1_title": "オーバーライドとは？",
  "cpp_lesson2_ex6_slide1_content": "# 親の機能を上書き\\n\\n**オーバーライド** は、親クラスで定義された関数を子クラスで書き換える機能です。`virtual` キーワードを使います。",
  "cpp_lesson2_ex6_slide2_title": "virtual と override",
  "cpp_lesson2_ex6_slide2_content": "# 仮想関数の仕組み\\n\\n親クラスで `virtual` をつけた関数は、子クラスで `override` して上書きできます。\\n\\n**コード例：**\\n```cpp\\nclass Animal {\\npublic:\\n    virtual void speak() { std::cout << \\\"...\\\" << std::endl; }\\n};\\nclass Cat : public Animal {\\npublic:\\n    void speak() override { std::cout << \\\"meow\\\" << std::endl; }\\n};\\n```",
  "cpp_lesson2_ex7_slide1_title": "テンプレートとは？",
  "cpp_lesson2_ex7_slide1_content": "# 汎用的（はんようてき）なコード\\n\\n**テンプレート**を使うと、どんな型（かた）でも使える汎用的な関数やクラスが作れます。\\n\\n**身近な例え：**\\n「2つの数を足す」関数を作りたいとき、整数用、小数用...と別々に作るのは大変ですよね。\\n\\nテンプレートを使えば、**型を後から決められる**「万能な設計図」が作れます。\\n\\n1つのコードで、int でも double でも使える！これがテンプレートの力です。",
  "cpp_lesson2_ex7_slide2_title": "関数テンプレート",
  "cpp_lesson2_ex7_slide2_content": "# template<typename T>\\n\\n`template<typename T>`（テンプレート・タイプネーム・ティー）と書くと、`T` が「後から決まる型」を表します。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// T はどんな型にもなれる\\ntemplate<typename T>\\nT add(T a, T b) {\\n    return a + b;\\n}\\n\\n// 使うとき、型が自動で決まる\\nadd(1, 2);       // T = int として動く\\nadd(1.5, 2.5);   // T = double として動く\\n```\\n\\n**ポイント：**\\n- `T` は「型のための変数」のようなもの\\n- 使われるときに、自動で適切な型に置き換わります\\n- 同じコードで、いろいろな型に対応できます！",
  "cpp_lesson2_ex8_slide1_title": "ラムダ式とは？",
  "cpp_lesson2_ex8_slide1_content": "# 無名関数（むめいかんすう）\\n\\n**ラムダ式（しき）** は、名前をつけずにその場で関数を作る方法です。\\n\\n**身近な例え：**\\n普通の関数は「料理のレシピに名前をつけて保存」するようなものです。\\nラムダ式は「その場でちょっと作るメモ書きレシピ」のようなもの。\\n\\n**いつ使うの？**\\n- 一度しか使わない短い処理\\n- 関数に渡す小さな処理\\n\\n短い処理を簡潔（かんけつ）に書けるのが魅力です！",
  "cpp_lesson2_ex9_slide1_title": "スマートポインタとは？",
  "cpp_lesson2_ex9_slide1_content": "# 安全なメモリ管理（かんり）\\n\\n**スマートポインタ**は、使い終わったら自動的にメモリを解放（かいほう）してくれる便利なポインタです。\\n\\n**身近な例え：**\\n普通のポインタは「借りた本を自分で返さないといけない」状態です。返し忘れると大変！\\n\\nスマートポインタは「自動返却システム」がついた本のようなもの。使い終わったら勝手に返してくれます。\\n\\n**メモリリーク**（メモリの解放忘れ）を防ぐことができます。",
  "cpp_lesson2_ex9_slide2_title": "unique_ptr の使い方",
  "cpp_lesson2_ex9_slide2_content": "# std::make_unique\\n\\n`std::make_unique<型>()` でスマートポインタを作ります。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n#include <memory>  // スマートポインタを使う準備\\n\\n// 整数を入れるスマートポインタを作る\\nauto p = std::make_unique<int>(42);\\n\\n// 中身を見る（*をつける）\\nstd::cout << *p << std::endl; // 42\\n\\n// ここでブロックを抜けると、自動でメモリが解放される！\\n```\\n\\n**用語解説：**\\n- `unique_ptr`: 1つのポインタだけが所有する（独占）\\n- **スコープを抜ける**: `{ }` の外に出ること\\n- 自動解放なので、`delete` を書く必要がない！",
  "cpp_lesson2_ex10_slide1_title": "例外処理（れいがいしょり）とは？",
  "cpp_lesson2_ex10_slide1_content": "# エラーに備（そな）える\\n\\n**例外処理（れいがいしょり）** を使うと、プログラム実行中のエラーに対処（たいしょ）できます。\\n\\n**身近な例え：**\\nサーカスの空中ブランコには、下に「安全ネット」がありますよね。万が一落ちても大丈夫なように。\\n\\n例外処理も同じです。プログラムで「万が一のエラー」が起きても、クラッシュせずに対処できる「安全ネット」を用意します。\\n\\nエラーが起きてもプログラムが止まらず、適切に対応できます！",
  "cpp_lesson2_ex10_slide2_title": "try-catch の使い方",
  "cpp_lesson2_ex10_slide2_content": "# throw で例外を投げる\\n\\n**基本の形：**\\n- `try { }`: エラーが起きるかもしれない処理\\n- `throw`: エラーを「投げる」\\n- `catch { }`: 投げられたエラーを「捕まえる」\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\ntry {\\n    // エラーを投げる\\n    throw \\\"error!\\\";\\n} catch (const char* e) {\\n    // 投げられたエラーを捕まえて処理\\n    std::cout << e << std::endl;\\n}\\n```\\n=> \\\"error!\\\" と表示されます\\n\\n**ポイント：**\\n- `throw` でエラーを投げると、すぐに `catch` に移動します\\n- `catch` でエラーに対処した後、プログラムは続行できます",
  "cpp_lesson3_ex1_slide1_title": "auto とは？",
  "cpp_lesson3_ex1_slide1_content": "# 型（かた）の自動推論（すいろん）\\n\\n**auto**（オート）を使うと、コンパイラ（プログラムを翻訳するソフト）が自動で型を判断してくれます。\\n\\n**身近な例え：**\\n「これはリンゴです」と言わなくても、見ればリンゴだとわかりますよね。`auto` は「見ればわかるでしょ？」とコンパイラに任せる書き方です。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nauto x = 42;        // 42は整数 → int型と自動判断\\nauto pi = 3.14;     // 3.14は小数 → double型と自動判断\\nauto name = \\\"Alice\\\"; // 文字列 → const char*型と自動判断\\n```\\n\\n**メリット：**\\n型を書く手間が省けて、コードがスッキリします！",
  "cpp_lesson3_ex1_slide2_title": "イテレータで便利",
  "cpp_lesson3_ex1_slide2_content": "# 長い型名を省略（しょうりゃく）\\n\\n`auto` は、型名が長くて書くのが大変なときに特に便利です。\\n\\n**イテレータ**（配列の中を順番に見ていくための道具）は型名がとても長いです。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nstd::vector<int> v = {1, 2, 3};\\n\\n// auto がないと...\\nstd::vector<int>::iterator it = v.begin();  // 長い！\\n\\n// auto を使うと...\\nauto it = v.begin();  // スッキリ！\\n\\nfor (auto it = v.begin(); it != v.end(); ++it) {\\n    std::cout << *it << std::endl;\\n}\\n```\\n\\n**ポイント：**\\n型が複雑になるほど、`auto` の便利さがわかります！",
  "cpp_lesson3_ex2_slide1_title": "範囲for文とは？",
  "cpp_lesson3_ex2_slide1_content": "# シンプルなループ構文（こうぶん）\\n\\nC++11の **範囲（はんい）for文** を使うと、配列やベクターの中身を簡単に1つずつ取り出せます。\\n\\n**身近な例え：**\\nお菓子の箱から順番にお菓子を取り出すイメージです。「箱の中のお菓子を1つずつ取り出して食べる」のように、配列の中の値を1つずつ取り出して処理できます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvector<int> v = {1, 2, 3};  // 数字が入った箱を作る\\nfor (int x : v) {            // 箱から1つずつ取り出す\\n    cout << x << endl;       // 取り出した数字を表示\\n}\\n// 出力: 1, 2, 3 が順番に表示される\\n```\\n\\n**ポイント：**\\n`:` は「〜の中から」という意味だと覚えましょう！",
  "cpp_lesson3_ex2_slide2_title": "参照で受け取る",
  "cpp_lesson3_ex2_slide2_content": "# コピーを避（さ）ける書き方\\n\\n通常の範囲for文は、要素を「コピー」して取り出します。大きなデータだとコピーに時間がかかります。\\n\\n**身近な例え：**\\n本を読むとき、毎回コピーを取って読むより、本棚にある本をそのまま読む方が早いですよね。\\n\\n**参照で受け取る書き方：**\\n```cpp\\nfor (const auto& x : v) {\\n    // & をつけると「参照」で受け取る（コピーしない）\\n    // const をつけると「変更しない」という約束\\n    cout << x << endl;\\n}\\n```\\n\\n**使い分け：**\\n- `int x` : 小さいデータ（int, charなど）はコピーでOK\\n- `const auto& x` : 大きいデータ（string, vectorなど）は参照が効率的\\n\\n`auto` を使うと型を自動で判断してくれるので便利です！",
  "cpp_lesson3_ex3_slide1_title": "nullptr とは？",
  "cpp_lesson3_ex3_slide1_content": "# 型安全（かたあんぜん）なヌル\\n\\n**nullptr**（ヌルポインタ）は、「どこも指していないポインタ」を表す特別な値です。\\n\\n**身近な例え：**\\n住所録に「住所なし」と書きたいとき、空欄にするより「なし」と明記した方が明確ですよね。`nullptr` は「このポインタはどこも指していません」と明示するための値です。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nint* p = nullptr;  // pはどこも指していない\\nif (p == nullptr) {\\n    cout << \\\"null\\\" << endl;  // nullと表示される\\n}\\n```\\n\\nC++11からは、古い `NULL` より `nullptr` を使うのが推奨されています。",
  "cpp_lesson3_ex3_slide2_title": "NULL との違い",
  "cpp_lesson3_ex3_slide2_content": "# なぜ nullptr の方が良いの？\\n\\n古い `NULL` は実は「0」という数字として扱われるため、問題が起きることがあります。\\n\\n**困る例：**\\n```cpp\\nvoid f(int);    // 整数を受け取る関数\\nvoid f(int*);   // ポインタを受け取る関数\\n\\nf(NULL);    // どっちの f() を呼ぶ？→ あいまい！\\nf(nullptr); // f(int*) が呼ばれる → 明確！\\n```\\n\\n**ポイント：**\\n- `NULL` は「0」という数字に見えることがある\\n- `nullptr` は「ポインタ専用のヌル」なので間違いが起きない\\n\\nモダンC++では、必ず `nullptr` を使いましょう！",
  "cpp_lesson3_ex4_slide1_title": "constexpr とは？",
  "cpp_lesson3_ex4_slide1_content": "# コンパイル時（じ）計算\\n\\n**constexpr**（コンストエクスプレス）は、「コンパイル時に計算できる」ことを示すキーワードです。\\n\\n**身近な例え：**\\n料理のレシピで「小さじ2杯」と書くか「10ml」と書くかの違いです。どちらも同じ量ですが、「10ml」と最初から計算済みで書いておく方が効率的ですよね。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nconstexpr int square(int x) {\\n    return x * x;\\n}\\nconstexpr int val = square(5); // コンパイル時に25と計算済み！\\n```\\n\\nプログラムを実行する前に計算が終わっているので、実行が速くなります。",
  "cpp_lesson3_ex4_slide2_title": "const との違い",
  "cpp_lesson3_ex4_slide2_content": "# コンパイル時 vs 実行時（じっこうじ）\\n\\n`const` と `constexpr` は似ていますが、違いがあります。\\n\\n**比較：**\\n```cpp\\n// const: 実行時に決まってもOK\\nconst int a = getValue();     // 関数を呼んで決まる\\n\\n// constexpr: コンパイル時に決まっていないとダメ\\nconstexpr int b = 10 * 10;    // コンパイル時に100と計算済み\\n```\\n\\n**わかりやすく言うと：**\\n- `const`: 「一度決めたら変えない」（いつ決まるかは問わない）\\n- `constexpr`: 「プログラムを動かす前に決まっている」\\n\\n**メリット：**\\n`constexpr` を使うと、プログラムの実行が速くなり、配列のサイズ指定などにも使えます。",
  "cpp_lesson3_ex5_slide1_title": "初期化子リストとは？",
  "cpp_lesson3_ex5_slide1_content": "# {} を使った統一的（とういつてき）な初期化\\n\\n**初期化子（しょきかし）リスト**は、波括弧（なみかっこ）`{}` を使って値を設定する方法です。\\n\\n**身近な例え：**\\n買い物リストを作るとき、`{りんご, バナナ, みかん}` のように書くイメージです。配列やベクターにまとめて値を入れられます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvector<int> v = {1, 2, 3};   // 数字を3つ入れたベクター\\nmap<string, int> m = {       // 名前と数字のペアを入れた辞書\\n    {\\\"りんご\\\", 100},\\n    {\\\"バナナ\\\", 80}\\n};\\n```\\n\\n**メリット：**\\n配列もベクターも同じ書き方で初期化できます！",
  "cpp_lesson3_ex5_slide2_title": "縮小変換を防ぐ",
  "cpp_lesson3_ex5_slide2_content": "# {} は型を厳（きび）しくチェック\\n\\n`{}` を使うと、データが失われる変換（縮小変換）を防いでくれます。\\n\\n**身近な例え：**\\n大きな荷物を小さな箱に無理やり詰めようとすると警告が出るようなものです。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// () や = を使った場合\\nint x = 3.14;   // OK（でも 3 になる。小数点以下が消える）\\nint y(3.14);    // OK（同じく 3 になる）\\n\\n// {} を使った場合\\nint z{3.14};    // エラー！小数点以下が消えるので拒否される\\n```\\n\\n**ポイント：**\\n- `()` や `=`: 縮小変換を許可（警告は出るかも）\\n- `{}`: 縮小変換を禁止（エラーになる）\\n\\n`{}` を使うと、意図しないデータ損失を防げて安全です！",
  "cpp_lesson3_ex6_slide1_title": "shared_ptr とは？",
  "cpp_lesson3_ex6_slide1_content": "# 共有（きょうゆう）所有権（しょゆうけん）のスマートポインタ\\n\\n**shared_ptr**（シェアードポインタ）は、「複数人で共有できる」スマートポインタです。\\n\\n**身近な例え：**\\n図書館の本のようなものです。本（データ）は1冊しかないけど、複数の人が「借りている」状態になれます。最後の1人が返却したときに、本棚に戻されます（メモリが解放される）。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nauto p1 = make_shared<int>(42);  // 本を借りる（1人目）\\nauto p2 = p1;                     // 同じ本を借りる（2人目）\\n// p1 を使い終わっても、p2 がまだ使っているので消えない\\n// p2 も使い終わると、自動で解放される\\n```\\n\\n**ポイント：**\\n`unique_ptr` は1人しか持てませんが、`shared_ptr` は複数人で持てます。",
  "cpp_lesson3_ex6_slide2_title": "make_shared",
  "cpp_lesson3_ex6_slide2_content": "# make_shared で効率的（こうりつてき）に作成\\n\\n`shared_ptr` を作るときは、`make_shared` 関数を使うのがオススメです。\\n\\n**身近な例え：**\\n「部品を買ってきて自分で組み立てる」より「完成品を買う」方が楽で効率的ですよね。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// オススメの書き方\\nauto p = make_shared<int>(100);  // 100という値を持つ共有ポインタ\\n\\n// 非推奨の書き方（動くけど効率が悪い）\\nshared_ptr<int> p(new int(100));\\n```\\n\\n**なぜ make_shared が良いの？**\\n- メモリの確保が1回で済む（効率的）\\n- 例外安全（エラーが起きてもメモリリークしない）\\n- コードがスッキリする\\n\\n`make_shared<型>(初期値)` の形で覚えましょう！",
  "cpp_lesson3_ex7_slide1_title": "move とは？",
  "cpp_lesson3_ex7_slide1_content": "# 所有権（しょゆうけん）の移動（いどう）\\n\\n**std::move**（ムーブ）は、データの「所有権」を別の変数に移す機能です。\\n\\n**身近な例え：**\\n引っ越しのようなものです。家具を「コピー」して新しい家に置くのではなく、元の家から「そのまま運び出す」ので速くて効率的。でも元の家は空っぽになります。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nstring s1 = \\\"Hello\\\";       // s1 に \\\"Hello\\\" が入っている\\nstring s2 = move(s1);      // s1 の中身を s2 に移動！\\n// s1 は空っぽになる\\n// s2 に \\\"Hello\\\" が入っている\\ncout << s2 << endl;        // \\\"Hello\\\" と表示される\\n```\\n\\n**ポイント：**\\n`move` した後の変数（s1）は使わないようにしましょう。",
  "cpp_lesson3_ex7_slide2_title": "コピーより効率的",
  "cpp_lesson3_ex7_slide2_content": "# なぜ move が速いの？\\n\\n大きなデータを扱うとき、`move` はコピーより圧倒的（あっとうてき）に速いです。\\n\\n**身近な例え：**\\n100冊の本を別の部屋に移したいとき：\\n- **コピー**: 1冊ずつコピー機でコピーして運ぶ（遅い！）\\n- **ムーブ**: 本棚ごと運ぶ（速い！）\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvector<int> v1(1000000);  // 100万個の要素を持つベクター\\n\\n// コピー（遅い）: 100万個の要素を全部コピー\\nvector<int> v2 = v1;\\n\\n// ムーブ（速い）: 内部のポインタだけ移動\\nvector<int> v3 = move(v1);\\n// v1 は空になる\\n```\\n\\n**使いどころ：**\\n- 大きなデータを関数に渡すとき\\n- 元のデータをもう使わないとき\\n- 効率を重視するとき",
  "cpp_lesson3_ex8_slide1_title": "optional とは？",
  "cpp_lesson3_ex8_slide1_content": "# 「値があるかもしれない」を表す型\\n\\n**std::optional**（オプショナル）は、「値があるかもしれないし、ないかもしれない」という状態を安全に表現できる型です。\\n\\n**身近な例え：**\\nプレゼントの箱を想像してください。箱を開けたら「プレゼントが入っている」か「空っぽ」かのどちらかです。`optional` はこの「入っているかもしれない箱」を表します。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// 数字を探す関数（見つかるかもしれないし、見つからないかも）\\noptional<int> find(vector<int>& v, int x) {\\n    for (int n : v) {\\n        if (n == x) return n;     // 見つかったら値を返す\\n    }\\n    return nullopt;               // 見つからなかったら「空」を返す\\n}\\n```\\n\\n**用語解説：**\\n- `nullopt`: 「値がない」ことを表す特別な値",
  "cpp_lesson3_ex8_slide2_title": "値の取得",
  "cpp_lesson3_ex8_slide2_content": "# 値を安全に取り出す方法\\n\\n`optional` の中身を取り出す前に、「値があるか」をチェックします。\\n\\n**身近な例え：**\\nプレゼントの箱を開ける前に、「中身が入っているか」確認してから開けるようなものです。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\noptional<int> result = find(v, 5);\\n\\n// 方法1: has_value() でチェック\\nif (result.has_value()) {\\n    cout << result.value() << endl;  // 中身を取り出す\\n}\\n\\n// 方法2: if文で直接チェック（省略形）\\nif (result) {\\n    cout << *result << endl;  // * で中身を取り出す\\n}\\n```\\n\\n**注意：**\\n値がないのに `value()` を呼ぶとエラーになります。必ずチェックしてから使いましょう！",
  "cpp_lesson4_ex1_slide1_title": "unique_ptr とは？",
  "cpp_lesson4_ex1_slide1_content": "# 排他的（はいたてき）所有権（しょゆうけん）のスマートポインタ\\n\\n**unique_ptr**（ユニークポインタ）は、「1人だけが持てる」スマートポインタです。\\n\\n**身近な例え：**\\n映画のチケットのようなものです。1枚のチケットは1人しか持てません。他の人に渡したら、自分は映画を見られなくなります。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nauto p = make_unique<int>(42);  // 42という値を持つ専用のポインタ\\ncout << *p << endl;             // 42と表示される\\n// ここでスコープを出ると、自動でメモリが解放される！\\n```\\n\\n**メリット：**\\n- `delete` を書き忘れてもメモリリークしない\\n- 誰が所有者かが明確",
  "cpp_lesson4_ex1_slide2_title": "コピー不可",
  "cpp_lesson4_ex1_slide2_content": "# コピーはできない、移動（いどう）のみ\\n\\n`unique_ptr` は「1人だけ」が鉄則なので、コピーできません。\\n\\n**身近な例え：**\\n映画のチケットをコピーしたら、同じ席に2人座ることになって困りますよね。だからコピーは禁止。でも「渡す」ことはできます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nauto p1 = make_unique<int>(10);  // p1 が所有者\\n\\n// auto p2 = p1;           // エラー！コピーは禁止\\nauto p2 = move(p1);         // OK！p1 から p2 に渡す\\n// p1 はもう使えない（空っぽ）\\n// p2 が新しい所有者\\n```\\n\\n**ポイント：**\\n- コピー（複製）は禁止\\n- ムーブ（移動）はOK\\n- 移動後の元の変数は使わないこと",
  "cpp_lesson4_ex2_slide1_title": "variant とは？",
  "cpp_lesson4_ex2_slide1_content": "# 型安全（かたあんぜん）な「どれか1つ」型\\n\\n**std::variant**（バリアント）は、「いくつかの型のうち、どれか1つ」を安全に保持できます。\\n\\n**身近な例え：**\\n自動販売機のボタンのようなものです。「コーラ」「お茶」「水」のボタンがあって、押せるのは1つだけ。variant は「int か string のどちらか1つ」を保持できます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvariant<int, string> v;  // int か string のどちらかを入れられる箱\\n\\nv = 42;        // 今は int を保持中\\nv = \\\"hello\\\";   // 今は string を保持中（int は消える）\\n```\\n\\n**メリット：**\\n今どの型が入っているかを追跡してくれるので安全！",
  "cpp_lesson4_ex2_slide2_title": "値の取得",
  "cpp_lesson4_ex2_slide2_content": "# 中身を取り出す方法\\n\\nvariant から値を取り出すには、「今何が入っているか」をチェックします。\\n\\n**身近な例え：**\\n宝箱を開ける前に「中身は金貨？宝石？」と確認してから取り出すイメージです。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvariant<int, string> v = 42;\\n\\n// holds_alternative で「今 int が入っている？」と確認\\nif (holds_alternative<int>(v)) {\\n    cout << get<int>(v) << endl;  // get<int> で int として取り出す\\n}\\n\\n// 間違った型で取り出そうとするとエラー！\\n// get<string>(v);  // 今は int が入っているのでダメ\\n```\\n\\n**ポイント：**\\n- `holds_alternative<型>(v)`: その型が入っているか確認\\n- `get<型>(v)`: その型として取り出す",
  "cpp_lesson4_ex3_slide1_title": "構造化束縛とは？",
  "cpp_lesson4_ex3_slide1_content": "# 複数（ふくすう）の値を一度に受け取る\\n\\n**構造化束縛（こうぞうかそくばく）**は、まとまったデータを一度にバラバラの変数に分けて受け取る機能です。\\n\\n**身近な例え：**\\nプレゼント袋から「お菓子」「おもちゃ」「カード」を一気に取り出して、それぞれ別の箱に入れるイメージです。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\npair<int, string> p = {1, \\\"hello\\",
  "cpp_lesson4_ex4_slide1_title": "string_view とは？",
  "cpp_lesson4_ex4_slide1_content": "# 文字列（もじれつ）への軽量（けいりょう）ビュー\\n\\n**string_view**（ストリングビュー）は、文字列を「コピーせずに見る」ための型です。\\n\\n**身近な例え：**\\n図書館で本を「借りる」代わりに「その場で読む」ようなものです。本をコピーしないので速くて効率的！\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvoid print(string_view sv) {  // 文字列をコピーせずに受け取る\\n    cout << sv << endl;\\n}\\n\\nprint(\\\"hello\\\");  // 文字列リテラルもOK\\nstring s = \\\"world\\\";\\nprint(s);        // string型もOK\\n```\\n\\n**メリット：**\\nどんな種類の文字列でも、コピーなしで受け取れます！",
  "cpp_lesson4_ex4_slide2_title": "メリット",
  "cpp_lesson4_ex4_slide2_content": "# なぜ string_view が便利なの？\\n\\nこれまでの書き方と比べてみましょう。\\n\\n**身近な例え：**\\n写真を見せるとき、「実物の写真」でも「スマホの画面」でも、見る分には同じですよね。string_view は両方受け取れます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// 方法1: string で受け取る（コピーが発生）\\nvoid f1(string s);     // 毎回コピー = 遅い\\n\\n// 方法2: const string& で受け取る\\nvoid f2(const string& s);  // \\\"hello\\\" を渡すと一時オブジェクトが作られる\\n\\n// 方法3: string_view で受け取る（オススメ！）\\nvoid f3(string_view sv);   // コピーなし、どんな文字列もOK！\\n\\nstring s = \\\"world\\\";\\nf3(s);        // string型 → OK\\nf3(\\\"hello\\\");  // 文字列リテラル → OK\\nf3(\\\"abc\\\");    // const char* → OK\\n```\\n\\n関数の引数で「文字列を読むだけ」なら string_view が最適！",
  "cpp_lesson4_ex6_slide1_title": "accumulate とは？",
  "cpp_lesson4_ex6_slide1_content": "# 要素（ようそ）を全部まとめる\\n\\n**accumulate**（アキュムレート）は、配列の全要素を1つの値にまとめるアルゴリズムです。\\n\\n**身近な例え：**\\n貯金箱に毎日お金を入れていって、最後に全部でいくらか数えるイメージです。「累計」や「合計」を計算できます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\nvector<int> v = {1, 2, 3, 4, 5};\\n\\n// 全部足し算する（初期値は 0）\\nint sum = accumulate(v.begin(), v.end(), 0);\\n//                   ↑開始    ↑終了    ↑初期値\\n\\n// 0 + 1 + 2 + 3 + 4 + 5 = 15\\ncout << sum << endl;  // 15\\n```\\n\\n引数: (開始, 終了, 初期値)",
  "cpp_lesson4_ex9_slide1_title": "例外処理",
  "cpp_lesson4_ex9_slide1_content": "# try-catch でエラーを安全に処理（しょり）\\n\\n**例外処理（れいがいしょり）**は、プログラムでエラーが起きたときに安全に対処する仕組みです。\\n\\n**身近な例え：**\\nサーカスの綱渡りで、落ちたときに備えて「セーフティネット」を張っておくようなものです。エラーが起きても、プログラムがクラッシュせずに済みます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\ntry {                                // ここで危険な処理をする\\n    throw runtime_error(\\\"Error!\\\");   // エラーを「投げる」\\n} catch (const exception& e) {       // エラーを「捕まえる」\\n    cout << e.what() << endl;        // エラーメッセージを表示\\n}\\n// プログラムは続行できる！\\n```\\n\\n**用語解説：**\\n- `throw`: エラーを投げる\\n- `catch`: エラーを捕まえる\\n- `e.what()`: エラーメッセージを取得",
  "cpp_lesson4_ex9_slide2_title": "標準例外",
  "cpp_lesson4_ex9_slide2_content": "# よく使う例外（れいがい）の種類\\n\\nC++には、よくあるエラーのための「例外クラス」が用意されています。\\n\\n**身近な例え：**\\n病院の「症状別窓口」のようなものです。「風邪」「怪我」「健康診断」で窓口が違うように、エラーの種類で対応を変えられます。\\n\\n**よく使う例外一覧：**\\n```cpp\\nruntime_error     // 実行時エラー（一般的なエラー）\\nlogic_error       // 論理エラー（プログラムのバグ）\\nout_of_range      // 範囲外アクセス（配列の外を見ようとした）\\ninvalid_argument  // 不正な引数（おかしな値が渡された）\\n```\\n\\n**使い分けの例：**\\n```cpp\\nif (index >= array.size()) {\\n    throw out_of_range(\\\"インデックスが範囲外です\\\");\\n}\\nif (age < 0) {\\n    throw invalid_argument(\\\"年齢は0以上である必要があります\\\");\\n}\\n```",
  "cpp_lesson4_ex10_slide1_title": "noexcept とは？",
  "cpp_lesson4_ex10_slide1_content": "# 「例外を投げません」という約束\\n\\n**noexcept**（ノーエクセプト）は、「この関数は例外を投げません」と宣言するキーワードです。\\n\\n**身近な例え：**\\n「この道は絶対に通行止めになりません」という保証のようなものです。安心して通れるので、より効率的な経路が選べます。\\n\\n**実際のコードを見てみましょう：**\\n```cpp\\n// 「例外を投げない」と約束する関数\\nvoid safe() noexcept {\\n    int x = 1 + 1;  // 絶対にエラーが起きない処理\\n}\\n\\n// 例外を投げる可能性がある関数（noexcept なし）\\nvoid risky() {\\n    throw runtime_error(\\\"Error!\\\");  // エラーを投げるかも\\n}\\n```\\n\\n**ポイント：**\\n`noexcept` をつけた関数内で例外を投げると、プログラムが強制終了します。",
  "cpp_lesson4_ex10_slide2_title": "メリット",
  "cpp_lesson4_ex10_slide2_content": "# noexcept をつけると何が良いの？\\n\\n`noexcept` には2つの大きなメリットがあります。\\n\\n**メリット1: プログラムが速くなる**\\n```cpp\\nint add(int a, int b) noexcept {\\n    return a + b;\\n}\\n// コンパイラが「例外処理のコード」を省略できる → 速い！\\n```\\n\\n**メリット2: ムーブが安全に使える**\\n```cpp\\nclass MyClass {\\npublic:\\n    // noexcept をつけると、vectorなどで効率的に使われる\\n    MyClass(MyClass&&) noexcept = default;\\n};\\n```\\n\\n**身近な例え：**\\nレストランで「この料理はアレルギー物質を含みません」と保証されていれば、安心して注文できますよね。`noexcept` も同じで、「エラーは起きません」と保証することで、周りのコードが安心して使えます。\\n\\n**使いどころ：**\\n- 単純な計算（足し算、掛け算など）\\n- ムーブコンストラクタ、ムーブ代入演算子",
  "java_lesson1_ex1_slide1_title": "Java（ジャバ）とは？",
  "java_lesson1_ex1_slide1_content": "# 世界中で使われる「きっちりした」言葉\\n\\nJava（ジャバ）は、世界中の銀行（ぎんこう）や、Androidスマホのアプリなどで使われている、とても信頼（しんらい）できるプログラミング言語です。\\n\\n**たとえ話：** Javaは「厳格（げんかく）な先生」のようなものです。ルールは厳しいけれど、そのおかげで間違いの少ない安全なプログラムを作ることができます。",
  "java_lesson1_ex2_slide1_title": "変数（へんすう）とは？",
  "java_lesson1_ex2_slide1_content": "# データを保存する「はこ」\\n\\nプログラムの中では、数字や文字をしまっておく「はこ」を作ることができます。これを **変数（へんすう）** と呼びます。\\n\\n**たとえ話：** 変数は「名前のついた引き出し」のようなものです。「おかしの引き出し」「おもちゃの引き出し」のように、中身がわかる名前をつけてあげましょう！",
  "java_lesson1_ex2_slide2_title": "はこに「ラベル」を貼ろう",
  "java_lesson1_ex2_slide2_content": "# String（ストリング）ラベル\\n\\nJavaでは、はこを作るときに「このはこには何を入れますか？」と聞かれます。\\n\\n**たとえ話：** おもちゃ箱には「おもちゃ」、本棚には「本」と書いてあるように、Javaの変数にも「何を入れるか」を教えてあげる必要があります。\\n\\n「文字を入れたい！」というときは、`String`（ストリング＝文字列という意味）というラベルを使います。**Sが大文字** なので気をつけてくださいね！\\n\\n**コード例：** 下のコードが何をしているか見てみましょう\\n```java\\nString animal = \\\"いぬ\\\";  // 「animal」という名前の箱に「いぬ」を入れる\\nSystem.out.println(animal);  // 箱の中身を画面に出す\\n```\\n=> いぬ",
  "java_lesson1_ex3_slide1_title": "数字用のラベル",
  "java_lesson1_ex3_slide1_content": "# int（イント）ラベル\\n\\n数字（整数＝せいすう：小数点のない数字のこと）を扱いたいときは、**int**（イント）というラベルを使います。\\n\\n**覚え方：** int は「integer（インテジャー＝整数）」の略です。\\n\\n**使い分けのルール：**\\n- 文字を入れたい → `String`\\n- 数字を入れたい → `int`\\n\\nこの使い分けがJavaの大事なルールです！",
  "java_lesson1_ex3_slide2_title": "計算してみよう",
  "java_lesson1_ex3_slide2_content": "# 計算もできます\\n\\n`int` のはこに入れた数字は、たし算やひき算ができます。コンピュータは計算がとっても得意なんです！\\n\\n**コード例：** りんごとみかんの値段を足してみましょう\\n```java\\nint apple = 100;   // りんごは100円\\nint orange = 50;   // みかんは50円\\nSystem.out.println(apple + orange);  // 合計を表示\\n```\\n=> 150\\n\\n`+` を使うと、変数どうしを足し算できます。",
  "java_lesson1_ex4_slide1_title": "あまりを求める",
  "java_lesson1_ex4_slide1_content": "# 割り算の「あまり」を知りたい！\\n\\n割り算をしたときに、割り切れなくて「あまり」が出ることがありますよね。\\n\\n**たとえ話：** 10個のあめを3人で分けると、1人3個ずつで、1個あまります。この「あまり」を計算してくれるのが `%`（パーセント）記号です。\\n\\nこの計算を「剰余（じょうよ）」と呼びます。難しい言葉ですが、「あまりを求める計算」と覚えておけばOKです！",
  "java_lesson1_ex4_slide2_title": "% の使い方",
  "java_lesson1_ex4_slide2_content": "# あまりを計算してみよう\\n\\n**例1：あまりが出る場合**\\n```java\\nSystem.out.println(10 % 3);  // 結果: 1\\n```\\n10 ÷ 3 = 3 あまり **1** なので、「1」が表示されます。\\n\\n**例2：割り切れる場合**\\n```java\\nSystem.out.println(8 % 2);   // 結果: 0\\n```\\n8 ÷ 2 = 4 あまり **0** なので、「0」になります。\\n\\n**ポイント：** あまりが0なら「割り切れる」ということです！偶数（ぐうすう）かどうかの判定などに使えます。",
  "java_lesson1_ex5_slide1_title": "中身を増やしたいとき",
  "java_lesson1_ex5_slide1_content": "# はこの中身をパワーアップ\\n\\n**たとえ話：** ゲームで「今の点数に10点プラスしたい！」というとき、`+=` を使うととっても便利です。\\n\\nこれは「今の数字に足して、そのまま保存する」という合体技（がったいわざ）です。\\n\\n**コード例：**\\n```java\\nint score = 100;   // 最初は100点\\nscore += 10;       // 10点プラス！\\n// score は 110 になる\\n```\\n\\n**書き方の意味：**\\n`score += 10` は `score = score + 10` と同じ意味です。短くて便利ですね！",
  "java_lesson1_ex5_slide2_title": "-= も使える",
  "java_lesson1_ex5_slide2_content": "# 引き算バージョン\\n\\n`-=` を使えば、「今の数字から引いて保存」ができます。\\n\\n**たとえ話：** ゲームでダメージを受けてHP（体力）が減るときに使えます！\\n\\n**コード例：**\\n```java\\nint hp = 100;   // 最初のHP（体力）は100\\nhp -= 30;       // 30のダメージを受けた！\\n// hp は 70 になる\\n```\\n\\n**ほかにも：**\\n- `*=` → かけ算して保存\\n- `/=` → 割り算して保存",
  "java_lesson1_ex6_slide1_title": "連結（れんけつ）とは？",
  "java_lesson1_ex6_slide1_content": "# 複数の情報を合体させる\\n\\n「私は〇〇歳です」の「〇〇」のところに、変数（はこ）の中身を入れたいことがありますよね。\\n\\n**たとえ話：** パズルのピースをつなげるように、文字と変数を `+` でくっつけることができます。\\n\\nこれを **連結（れんけつ）** と呼びます。「つなげる」という意味です。",
  "java_lesson1_ex6_slide2_title": "プラスでつなげましょう",
  "java_lesson1_ex6_slide2_content": "# ガチャンと合体！\\n\\n文字と文字、文字と数字を `+` でつなぐと、ひとつの長い文章になります。\\n\\n**コード例：** 天気を表示してみましょう\\n```java\\nString weather = \\\"はれ\\\";  // 天気を変数に入れる\\nSystem.out.println(\\\"明日は\\\" + weather + \\\"です\\\");  // つなげて表示\\n```\\n=> 明日ははれです\\n\\n**何が起きているの？**\\n1. 「明日は」という文字\\n2. weatherの中身「はれ」\\n3. 「です」という文字\\n\\nこの3つが `+` でつながって「明日ははれです」になります！",
  "java_lesson1_ex7_slide1_title": "配列（はいれつ）とは？",
  "java_lesson1_ex7_slide1_content": "# データをまとめて整理整頓\\n\\nたくさんのデータを順番に並べておきたいときに使うのが **配列（はいれつ）** です。\\n\\n**たとえ話：** 配列は「ロッカー」のようなものです。1番のロッカー、2番のロッカー...というように、番号のついた場所にデータをしまっておけます。\\n\\n「買い物リスト」や「クラスの名簿（めいぼ）」のように、関連するものを一つの変数にまとめて管理（かんり）できます。",
  "java_lesson1_ex8_slide1_title": "条件分岐（じょうけんぶんき）とは？",
  "java_lesson1_ex8_slide1_content": "# プログラムに判断させてみよう\\n\\n「もし雨が降ったら傘をさす」「もし晴れたら外で遊ぶ」\\n\\nこんなふうに、状況（じょうきょう）によって動きを変えることを **条件分岐（じょうけんぶんき）** と呼びます。\\n\\n**たとえ話：** 条件分岐は「分かれ道」のようなものです。「テストで80点以上なら合格、そうでなければ不合格」のように、条件によって進む道が変わります。\\n\\nプログラムに「もし〜なら、これをしてね」と教えてあげましょう！",
  "java_lesson1_ex8_slide2_title": "もし〜なら（if）",
  "java_lesson1_ex8_slide2_content": "# if（イフ）の使い方\\n\\n`if` は英語で「もし」という意味です。Javaでは、`if (条件)` のあとに `{ }` を書いて、その中にやりたいことを書きます。\\n\\n**コード例：** 値段が1000円より高いかチェックしてみよう\\n```java\\nint price = 1200;  // 値段は1200円\\nif (price > 1000) {  // もし1000円より高いなら...\\n    System.out.println(\\\"ちょっと高いかも？\\\");\\n}\\n```\\n\\n**ポイント：**\\n- `>` は「より大きい」という意味\\n- 条件が正しいときだけ `{ }` の中が実行されます",
  "java_lesson1_ex9_slide1_title": "それ以外の場合は？",
  "java_lesson1_ex9_slide1_content": "# 2つの道を作る\\n\\n「もし〜なら」に当てはまらなかったときの動きも作ってみましょう。\\n\\n**たとえ話：** 「もし晴れなら外で遊ぶ、**そうでなければ**家でゲーム」のように、条件に当てはまらない場合の行動も決めておきたいですよね。\\n\\n**else（エルス）** を使うと、「そうじゃなければ、こっちをしてね」という指示が出せます。elseは英語で「そうでなければ」という意味です。",
  "java_lesson1_ex9_slide2_title": "そうじゃなければ（else）",
  "java_lesson1_ex9_slide2_content": "# 2つのルート\\n\\n条件にあてはまらなかったときの動きは `else` を使って書きます。\\n\\n**コード例：** 今は午前中かな？お昼すぎかな？\\n```java\\nint hour = 15;  // 今は15時\\nif (hour < 12) {  // もし12時より前なら...\\n    System.out.println(\\\"午前中\\\");\\n} else {  // そうでなければ...\\n    System.out.println(\\\"お昼すぎ\\\");\\n}\\n```\\n=> お昼すぎ\\n\\n**ポイント：**\\n- 15時は12時より前ではないので、`else` の中が実行されます\\n- `<` は「より小さい」という意味です",
  "java_lesson1_ex10_slide1_title": "条件を組み合わせる",
  "java_lesson1_ex10_slide1_content": "# もっと細かい条件で\\n\\n「10歳以上、**かつ**、20歳未満」のように、2つの条件を**両方**クリアしているかチェックしたいときがあります。\\n\\n**たとえ話：** 遊園地で「身長120cm以上**かつ**10歳以上なら乗れる」というルールがあるように、複数の条件を組み合わせたいことがありますよね。\\n\\n- 両方満たす必要がある → `&&`（アンド＝かつ）\\n- どちらか片方でもOK → `||`（オア＝または）",
  "java_lesson1_ex10_slide2_title": "&&（かつ）と ||（または）",
  "java_lesson1_ex10_slide2_content": "# 使い分け\\n\\n**例1：両方の条件を満たす（かつ）**\\n```java\\n// 点数80点以上、かつ、出席率90%以上なら...\\nif (score >= 80 && attendance >= 90) {\\n    System.out.println(\\\"優秀！\\\");\\n}\\n```\\n\\n**例2：どちらかを満たす（または）**\\n```java\\n// 土曜日、または、日曜日なら...\\nif (day == \\\"土曜日\\\" || day == \\\"日曜日\\\") {\\n    System.out.println(\\\"お休み\\\");\\n}\\n```\\n\\n**覚え方：**\\n- `&&` → 「**かつ**」両方必要\\n- `||` → 「**または**」どちらか1つでOK",
  "java_lesson1_ex11_slide1_title": "繰り返し（ループ）とは？",
  "java_lesson1_ex11_slide1_content": "# 面倒なことはコンピュータにおまかせ\\n\\n同じ作業を何度も繰り返すための仕組みが **ループ（繰り返し）** です。\\n\\n**たとえ話：** クラス全員の名前を呼ぶとき、「たろうくん」「はなこさん」「けんたくん」...と一人ずつ名前を書くのは大変ですよね。ループを使えば「全員の名前を順番に呼ぶ」と1回書くだけでOKです！\\n\\n配列の中身を一つずつ順番に全部チェックしたいときに非常に役立ちます。",
  "java_lesson1_ex12_slide1_title": "辞書（じしょ）とは？",
  "java_lesson1_ex12_slide1_content": "# キーワードで検索！\\n\\n**たとえ話：** 国語辞典で「りんご」を調べると「赤い果物」と出てくるように、「言葉」と「その意味」をセットにして保存できるのが **HashMap（ハッシュマップ）** です。\\n\\nJavaでは「辞書」のことを HashMap と呼びます。\\n\\n**使える場面：**\\n- 「名前」と「電話番号」のペア\\n- 「商品名」と「値段」のペア\\n- 「英単語」と「日本語訳」のペア",
  "java_lesson1_ex12_slide2_title": "HashMapの使い方",
  "java_lesson1_ex12_slide2_content": "# ちょっと準備が大変かも？\\n\\nJavaで辞書を使うのは少し準備が必要です。3ステップで覚えましょう！\\n\\n**ステップ1：** `import` で道具箱から出してくる\\n**ステップ2：** `new` で新しく作る\\n**ステップ3：** `put`（プット）で中身を入れる\\n\\n**コード例：**\\n```java\\nimport java.util.HashMap;  // ステップ1：道具を準備\\nHashMap<String, String> colors = new HashMap<>();  // ステップ2：辞書を作る\\ncolors.put(\\\"りんご\\\", \\\"あか\\\");  // ステップ3：データを入れる\\nSystem.out.println(colors.get(\\\"りんご\\\"));  // getで取り出す\\n```\\n=> あか",
  "java_lesson1_ex13_slide1_title": "メソッド（関数）とは？",
  "java_lesson1_ex13_slide1_content": "# オリジナルの技を作ろう\\n\\nよく使う処理をひとまとめにして、名前をつけることができます。これを **メソッド（関数・かんすう）** と呼びます。\\n\\n**たとえ話：** メソッドは「必殺技（ひっさつわざ）」のようなものです。「かめはめ波」と叫べば同じ技が出るように、メソッドも名前を呼べば同じ処理が実行されます。\\n\\n一度作っておけば、何度でも呼び出して使えます！",
  "java_lesson1_ex13_slide2_title": "メソッドを定義する",
  "java_lesson1_ex13_slide2_content": "# 作り方\\n\\nJavaでメソッドを作るときは、`public static void`（パブリック・スタティック・ボイド）という呪文（じゅもん）を使います。今は「おまじない」だと思ってそのまま書きましょう！\\n\\n**コード例：** あいさつするメソッドを作ってみよう\\n```java\\n// メソッドを作る（定義する）\\npublic static void aisatsu() {\\n    System.out.println(\\\"こんにちは！\\\");\\n}\\n\\n// メソッドを使う（呼び出す）\\naisatsu();  // 「こんにちは！」と表示される\\n```\\n\\n**ポイント：**\\n- メソッド名のあとに `()` をつけて呼び出します\\n- 同じメソッドを何回でも呼び出せます",
  "java_lesson2_ex1_slide1_title": "継承（けいしょう）とは？",
  "java_lesson2_ex1_slide1_content": "# クラスを拡張（かくちょう）する\\n\\n**継承（けいしょう）** とは、すでにあるクラス（親クラス）の機能（きのう）を引き継いで新しいクラス（子クラス）を作る仕組みです。\\n\\n**たとえ話：** 親から子へ「目の色」や「髪の色」が受け継がれるように、プログラムでも親クラスの機能が子クラスに受け継がれます。\\n\\n`extends`（エクステンズ＝拡張する）というキーワードを使います。\\n\\n```java\\nclass Animal {  // 親クラス（動物）\\n    void eat() { System.out.println(\\\"食べる\\\"); }\\n}\\n\\nclass Dog extends Animal {  // 子クラス（犬）はAnimalを継承\\n    void bark() { System.out.println(\\\"ワン！\\\"); }\\n}\\n```",
  "java_lesson2_ex1_slide2_title": "親クラスの機能を使う",
  "java_lesson2_ex1_slide2_content": "# 継承した機能\\n\\n子クラスは親クラスのメソッドをそのまま使えます。犬（Dog）は動物（Animal）なので、「食べる」ことができますね！\\n\\n**コード例：**\\n```java\\nDog dog = new Dog();  // 犬を作る\\ndog.eat();   // 親のメソッド → 「食べる」\\ndog.bark();  // 自分のメソッド → 「ワン！」\\n```\\n\\n**ポイント：** 子クラスは親の機能＋自分だけの機能を持てます。Dogは「食べる」も「ほえる」もできます！",
  "java_lesson2_ex2_slide1_title": "オーバーライドとは？",
  "java_lesson2_ex2_slide1_content": "# メソッドを上書き（うわがき）\\n\\n**オーバーライド** とは、親クラスのメソッドを子クラスで書き換えることです。\\n\\n**たとえ話：** 動物は「音を出す」ことができますが、犬は「ワン！」、猫は「ニャー」と、動物の種類によって音が違いますよね。オーバーライドを使えば、子クラスごとに違う動きを定義できます。\\n\\n```java\\nclass Animal {\\n    void sound() { System.out.println(\\\"音\\\"); }\\n}\\n\\nclass Cat extends Animal {\\n    @Override  // ←「上書きするよ」という印\\n    void sound() { System.out.println(\\\"ニャー\\\"); }\\n}\\n```",
  "java_lesson2_ex2_slide2_title": "@Override アノテーション",
  "java_lesson2_ex2_slide2_content": "# 明示的（めいじてき）に宣言\\n\\n`@Override`（アット・オーバーライド）は「このメソッドは親のメソッドを上書きしますよ」という印（しるし）です。\\n\\n**アノテーション** とは、プログラムに追加情報を与える「ふせん」のようなものです。\\n\\n**なぜ使うの？**\\n- 間違いを防げます（スペルミスがあるとエラーで教えてくれる）\\n- コードが読みやすくなります\\n\\n```java\\nclass Cat extends Animal {\\n    @Override  // 「これは上書きです」と宣言\\n    void sound() {  // 親と同じメソッド名\\n        System.out.println(\\\"ニャー\\\");\\n    }\\n}\\n```",
  "java_lesson2_ex3_slide1_title": "インターフェースとは？",
  "java_lesson2_ex3_slide1_content": "# 契約（けいやく）を定義する\\n\\n**インターフェース** とは、クラスが持つべきメソッドの「約束事（やくそくごと）」を定義したものです。\\n\\n**たとえ話：** 「運転免許を持っている人は車を運転できる」という約束のようなものです。免許を持っている（implements）なら、運転できる（メソッドを持っている）ことが保証されます。\\n\\n`implements`（インプリメンツ＝実装する）で約束を守ります。\\n\\n```java\\ninterface Drawable {  // 「描ける」という約束\\n    void draw();  // このメソッドを持つこと！\\n}\\n\\nclass Square implements Drawable {  // 約束を守ります！\\n    public void draw() {  // 約束通りのメソッドを実装\\n        System.out.println(\\\"四角形\\\");\\n    }\\n}\\n```",
  "java_lesson2_ex3_slide2_title": "複数のインターフェース",
  "java_lesson2_ex3_slide2_content": "# 複数実装（じっそう）できる\\n\\nクラスは複数のインターフェースを実装できます。\\n\\n**たとえ話：** 一人の人が「運転免許」と「調理師免許」の両方を持てるように、クラスも複数の約束を守ることができます。\\n\\n```java\\ninterface A { void a(); }  // 約束A\\ninterface B { void b(); }  // 約束B\\n\\nclass C implements A, B {  // 両方の約束を守る\\n    public void a() { }  // 約束Aを実装\\n    public void b() { }  // 約束Bを実装\\n}\\n```\\n\\n**ポイント：** 継承（extends）は1つだけですが、インターフェース（implements）は何個でもOKです！",
  "java_lesson2_ex4_slide1_title": "抽象（ちゅうしょう）クラスとは？",
  "java_lesson2_ex4_slide1_content": "# 未完成の設計図（せっけいず）\\n\\n**抽象クラス** は、`abstract`（アブストラクト＝抽象的な）をつけた「未完成のクラス」です。\\n\\n**たとえ話：** 「動物」は存在しますが、実際には「犬」「猫」「鳥」など具体的な動物がいますよね。「動物」自体を作ることはできないけど、「動物としての共通点」は定義できます。それが抽象クラスです。\\n\\n- 直接 new で作れない（実体がない）\\n- 子クラスで完成させる\\n\\n```java\\nabstract class Animal {  // 抽象クラス\\n    abstract void sound();  // 「音を出す」は未定義\\n    void sleep() { System.out.println(\\\"Zzz\\\"); }  // 「寝る」は定義済み\\n}\\n```",
  "java_lesson2_ex4_slide2_title": "抽象メソッド",
  "java_lesson2_ex4_slide2_content": "# 子クラスで実装必須（ひっす）\\n\\n**抽象メソッド** は中身のないメソッドです。子クラスで**必ず**実装しなければなりません。\\n\\n**たとえ話：** 「動物は音を出す」というルールだけ決めておいて、「どんな音か」は犬や猫に任せる、という感じです。\\n\\n```java\\nclass Dog extends Animal {\\n    void sound() {  // 必ず実装する！\\n        System.out.println(\\\"ワン！\\\");\\n    }\\n}\\n```\\n\\n**インターフェースとの違い：**\\n- インターフェース：全部が約束（実装なし）\\n- 抽象クラス：一部は完成、一部は約束",
  "java_lesson2_ex6_slide1_title": "finally（ファイナリー）とは？",
  "java_lesson2_ex6_slide1_content": "# 必ず実行される\\n\\n`finally`（ファイナリー＝最後に）ブロックは、例外が起きても起きなくても**必ず**実行されます。\\n\\n**たとえ話：** 料理が成功しても失敗しても、最後は必ずキッチンを片付けますよね。それが finally です。\\n\\n```java\\ntry {\\n    // 処理（うまくいくかも、失敗するかも）\\n} catch (Exception e) {\\n    // エラー処理（失敗したときだけ）\\n} finally {\\n    // 必ず実行（成功でも失敗でも）\\n}\\n```",
  "java_lesson2_ex6_slide2_title": "リソースの解放に",
  "java_lesson2_ex6_slide2_content": "# 後片付け処理\\n\\nファイルを閉じる、接続（せつぞく）を切断（せつだん）するなどの後片付けに使います。\\n\\n**たとえ話：** 本を読み終わったら本棚に戻す、電気を使ったら消す、というように「終わったら必ずやること」を書きます。\\n\\n```java\\ntry {\\n    // ファイルを開いて操作する\\n} finally {\\n    // ファイルを閉じる（必ず実行）\\n    System.out.println(\\\"Clean up\\\");\\n}\\n```\\n\\n**ポイント：** finally があれば、エラーが起きても後片付けを忘れません！",
  "java_lesson2_ex7_slide1_title": "ArrayList（アレイリスト）とは？",
  "java_lesson2_ex7_slide1_content": "# 可変長（かへんちょう）の配列\\n\\n**ArrayList** は、サイズを自由に変えられるリストです。\\n\\n**たとえ話：** 普通の配列は「固定サイズの本棚」で、本の数が決まっています。でもArrayListは「伸び縮みする本棚」で、本を増やしたり減らしたりできます！\\n\\n```java\\nimport java.util.ArrayList;  // 道具を準備\\n\\nArrayList<String> list = new ArrayList<>();  // リストを作る\\nlist.add(\\\"Apple\\\");   // リンゴを追加\\nlist.add(\\\"Banana\\\");  // バナナを追加\\n// 好きなだけ追加できる！\\n```",
  "java_lesson2_ex9_slide1_title": "static（スタティック）とは？",
  "java_lesson2_ex9_slide1_content": "# クラスに属するメソッド\\n\\n**static**（スタティック＝静的な）メソッドは、インスタンス（実体）を作らなくても呼び出せるメソッドです。\\n\\n**たとえ話：** 普通のメソッドは「犬を飼ってから、その犬にお座りさせる」イメージ。staticメソッドは「犬を飼わなくても使える共通の技」のようなものです。\\n\\n```java\\nclass Math {\\n    static int add(int a, int b) {  // staticメソッド\\n        return a + b;\\n    }\\n}\\n\\nMath.add(3, 5);  // newしなくても呼べる！→ 8\\n```",
  "java_lesson2_ex9_slide2_title": "staticの特徴（とくちょう）",
  "java_lesson2_ex9_slide2_content": "# ユーティリティに便利\\n\\n**ユーティリティ**（便利ツール）をまとめるのに使います。みんなで共有する道具箱のようなものです。\\n\\n```java\\nclass Utils {\\n    static String upper(String s) {  // 大文字に変換\\n        return s.toUpperCase();\\n    }\\n}\\n\\nUtils.upper(\\\"hello\\\");  // \\\"HELLO\\\"\\n```\\n\\n**いつ使う？**\\n- 計算だけするメソッド（足し算、引き算など）\\n- 文字列を変換するメソッド\\n- 共通で使う便利機能",
  "java_lesson2_ex10_slide1_title": "アクセス修飾子（しゅうしょくし）とは？",
  "java_lesson2_ex10_slide1_content": "# 公開範囲（こうかいはんい）を制御\\n\\n**アクセス修飾子** は、「誰がこのデータを見れるか」を決めるキーワードです。\\n\\n**たとえ話：** 日記帳には「自分だけの秘密」があって、友達には見せませんよね。プログラムでも「見せていい情報」と「秘密にしたい情報」を分けられます。\\n\\n- `public`（パブリック）: 誰でもアクセスOK\\n- `private`（プライベート）: 自分のクラスだけ\\n- `protected`（プロテクテッド）: 子クラスもOK\\n\\n```java\\nclass User {\\n    public String name;   // 誰でも見れる\\n    private int id;       // 秘密！\\n}\\n```",
  "java_lesson2_ex10_slide2_title": "カプセル化（かぷせるか）",
  "java_lesson2_ex10_slide2_content": "# データを守る\\n\\n**カプセル化** とは、大事なデータを `private` で隠して、メソッド経由でアクセスする方法です。\\n\\n**たとえ話：** 銀行口座の残高は直接変更できません。必ず「入金」「出金」という手続き（メソッド）を通しますよね。それがカプセル化です。\\n\\n```java\\nclass User {\\n    private String name;  // 直接触れないようにする\\n    \\n    public String getName() {  // 取得用のメソッド\\n        return name;\\n    }\\n}\\n```\\n\\n**メリット：** データを勝手に変更されるのを防げます",
  "java_lesson3_ex1_slide1_title": "ラムダ式とは？",
  "java_lesson3_ex1_slide1_content": "# 簡潔な関数の書き方\\n\\n**ラムダ式** は、匿名関数を簡潔に書ける構文です。\\n\\n```java\\n// 従来の書き方\\nRunnable r = new Runnable() {\\n    public void run() { System.out.println(\\\"Hi\\\"); }\\n};\\n\\n// ラムダ式\\nRunnable r = () -> System.out.println(\\\"Hi\\\");\\n```",
  "java_lesson3_ex1_slide2_title": "構文",
  "java_lesson3_ex1_slide2_content": "# (引数) -> 処理\\n\\n```java\\n// 引数なし\\n() -> System.out.println(\\\"Hello\\\")\\n\\n// 引数1つ（カッコ省略可）\\nx -> x * 2\\n\\n// 引数複数\\n(a, b) -> a + b\\n```",
  "java_lesson3_ex2_slide1_title": "Stream とは？",
  "java_lesson3_ex2_slide1_content": "# データの流れを処理\\n\\n**Stream** は、コレクションの要素を順番に処理するためのAPIです。\\n\\n```java\\nList<String> list = Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\");\\nStream<String> stream = list.stream();\\n```",
  "java_lesson3_ex2_slide2_title": "Stream の作り方",
  "java_lesson3_ex2_slide2_content": "# いろいろな作成方法\\n\\n```java\\n// コレクションから\\nlist.stream()\\n\\n// 配列から\\nArrays.stream(array)\\n\\n// 値から直接\\nStream.of(1, 2, 3)\\n```",
  "java_lesson3_ex3_slide1_title": "map とは？",
  "java_lesson3_ex3_slide1_content": "# 要素を変換\\n\\n**map** は、各要素に関数を適用して変換します。\\n\\n```java\\nList<Integer> nums = Arrays.asList(1, 2, 3);\\nnums.stream()\\n    .map(n -> n * 2)\\n    .forEach(System.out::println);\\n// 2, 4, 6\\n```",
  "java_lesson3_ex3_slide2_title": "型の変換も可能",
  "java_lesson3_ex3_slide2_content": "# 異なる型に変換\\n\\n```java\\nList<String> names = Arrays.asList(\\\"a\\\", \\\"bb\\\", \\\"ccc\\\");\\nnames.stream()\\n     .map(String::length)\\n     .forEach(System.out::println);\\n// 1, 2, 3\\n```",
  "java_lesson3_ex4_slide1_title": "filter とは？",
  "java_lesson3_ex4_slide1_content": "# 条件で絞り込み\\n\\n**filter** は、条件を満たす要素だけを通します。\\n\\n```java\\nList<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);\\nnums.stream()\\n    .filter(n -> n % 2 == 0)\\n    .forEach(System.out::println);\\n// 2, 4\\n```",
  "java_lesson3_ex4_slide2_title": "複数条件",
  "java_lesson3_ex4_slide2_content": "# filterを連結\\n\\n```java\\nnums.stream()\\n    .filter(n -> n > 1)\\n    .filter(n -> n < 5)\\n    .forEach(System.out::println);\\n// 2, 3, 4\\n```",
  "java_lesson3_ex5_slide1_title": "collect とは？",
  "java_lesson3_ex5_slide1_content": "# Streamをコレクションに\\n\\n**collect** は、Streamの結果をリストなどに変換します。\\n\\n```java\\nList<Integer> result = nums.stream()\\n    .filter(n -> n > 0)\\n    .collect(Collectors.toList());\\n```",
  "java_lesson3_ex5_slide2_title": "様々なコレクタ",
  "java_lesson3_ex5_slide2_content": "# Collectorsのメソッド\\n\\n```java\\n// リストに\\nCollectors.toList()\\n\\n// セットに\\nCollectors.toSet()\\n\\n// 文字列結合\\nCollectors.joining(\\\", \\\")\\n```",
  "java_lesson3_ex6_slide1_title": "reduce とは？",
  "java_lesson3_ex6_slide1_content": "# 要素を1つに集約\\n\\n**reduce** は、全要素を1つの値にまとめます。\\n\\n```java\\nint sum = nums.stream()\\n    .reduce(0, (a, b) -> a + b);\\n// 初期値0から始めて全部足す\\n```",
  "java_lesson3_ex6_slide2_title": "様々な集約",
  "java_lesson3_ex6_slide2_content": "# 合計、最大値など\\n\\n```java\\n// 合計\\n.reduce(0, Integer::sum)\\n\\n// 積\\n.reduce(1, (a, b) -> a * b)\\n```",
  "java_lesson3_ex7_slide1_title": "Optional とは？",
  "java_lesson3_ex7_slide1_content": "# 値があるかもしれない容器\\n\\n**Optional** は、値が存在するかもしれないことを表す型です。\\n\\n```java\\nOptional<String> name = Optional.of(\\\"Alice\\\");\\nOptional<String> empty = Optional.empty();\\n```",
  "java_lesson3_ex7_slide2_title": "値の取得",
  "java_lesson3_ex7_slide2_content": "# 安全に値を取り出す\\n\\n```java\\nOptional<String> opt = Optional.of(\\\"Hello\\\");\\n\\n// 値があれば取得、なければデフォルト\\nString s = opt.orElse(\\\"default\\\");\\n\\n// 値があれば処理\\nopt.ifPresent(System.out::println);\\n```",
  "java_lesson3_ex8_slide1_title": "メソッド参照とは？",
  "java_lesson3_ex8_slide1_content": "# 既存メソッドをラムダとして使う\\n\\n**::** を使うと、既存のメソッドを参照できます。\\n\\n```java\\n// ラムダ式\\nx -> System.out.println(x)\\n\\n// メソッド参照\\nSystem.out::println\\n```",
  "java_lesson3_ex8_slide2_title": "様々なメソッド参照",
  "java_lesson3_ex8_slide2_content": "# 4つのパターン\\n\\n```java\\n// スタティックメソッド\\nInteger::parseInt\\n\\n// インスタンスメソッド（特定のオブジェクト）\\nSystem.out::println\\n\\n// インスタンスメソッド（任意のオブジェクト）\\nString::length\\n\\n// コンストラクタ\\nArrayList::new\\n```",
  "java_lesson3_ex9_slide1_title": "sorted とは？",
  "java_lesson3_ex9_slide1_content": "# 要素を並べ替え\\n\\n**sorted** は、要素を自然順序でソートします。\\n\\n```java\\nList<Integer> nums = Arrays.asList(3, 1, 2);\\nnums.stream()\\n    .sorted()\\n    .forEach(System.out::println);\\n// 1, 2, 3\\n```",
  "java_lesson3_ex9_slide2_title": "カスタムソート",
  "java_lesson3_ex9_slide2_content": "# Comparator を指定\\n\\n```java\\n// 逆順\\n.sorted(Comparator.reverseOrder())\\n\\n// 長さでソート\\n.sorted(Comparator.comparing(String::length))\\n```",
  "java_lesson3_ex10_slide1_title": "distinct とは？",
  "java_lesson3_ex10_slide1_content": "# 重複を除去\\n\\n**distinct** は、重複した要素を取り除きます。\\n\\n```java\\nList<Integer> nums = Arrays.asList(1, 2, 2, 3, 3, 3);\\nnums.stream()\\n    .distinct()\\n    .forEach(System.out::println);\\n// 1, 2, 3\\n```",
  "java_lesson3_ex10_slide2_title": "他のメソッドと組み合わせ",
  "java_lesson3_ex10_slide2_content": "# 効率的な処理\\n\\n```java\\nnums.stream()\\n    .filter(n -> n > 0)\\n    .distinct()\\n    .sorted()\\n    .collect(Collectors.toList());\\n```",
  "java_lesson4_ex1_slide1_title": "ジェネリクスとは？",
  "java_lesson4_ex1_slide1_content": "# 型を後から指定\\n\\n**ジェネリクス** は、クラスやメソッドの「型」を後から指定できる機能です。\\n\\n**たとえ話：** 「何でも入る箱」を作っておいて、使うときに「この箱は文字列専用」「この箱は数字専用」と決められます。\\n\\n```java\\n// T は「型の入れ物」（後で決める）\\nclass Box<T> {\\n    private T value;  // T型の値を保存\\n    public void set(T v) { value = v; }\\n    public T get() { return value; }\\n}\\n```\\n\\n`<T>` は「型パラメータ」と呼ばれ、後で String や Integer に置き換えます",
  "java_lesson4_ex1_slide2_title": "使い方",
  "java_lesson4_ex1_slide2_content": "# 型を指定して使う\\n\\n使うときに `<>` の中に具体的な型を書きます。\\n\\n**文字列用の箱**\\n```java\\nBox<String> box = new Box<>();  // String専用の箱\\nbox.set(\\\"Hello\\\");  // 文字列を入れる\\nString s = box.get();  // 文字列で取り出せる（キャスト不要！）\\n```\\n\\n**数字用の箱**\\n```java\\nBox<Integer> numBox = new Box<>();  // Integer専用の箱\\nnumBox.set(42);  // 数字を入れる\\n```\\n\\n**メリット：** 間違った型を入れようとするとエラーで教えてくれます",
  "java_lesson4_ex2_slide1_title": "extends で制約（せいやく）",
  "java_lesson4_ex2_slide1_content": "# 特定の型のサブタイプに限定\\n\\n**extends** を使うと、「このジェネリクスには〇〇の仲間だけ入れられます」という制限をつけられます。\\n\\n**たとえ話：** 「動物園の檻」には動物しか入れられないように、「Number（数字）の箱」には数字系の型しか入れられません。\\n\\n```java\\n// T は Number か、その子クラスだけOK\\nclass NumBox<T extends Number> {\\n    private T value;\\n    public double doubleValue() {\\n        return value.doubleValue();  // Numberのメソッドが使える！\\n    }\\n}\\n```",
  "java_lesson4_ex2_slide2_title": "メリット",
  "java_lesson4_ex2_slide2_content": "# 型固有（かたこゆう）のメソッドが使える\\n\\n制限をつけると、その型のメソッドが使えるようになります。\\n\\n**OKな例**\\n```java\\nNumBox<Integer> box = new NumBox<>();\\n// OK: Integer は Number の仲間\\n```\\n\\n**NGな例**\\n```java\\nNumBox<String> box2; \\n// コンパイルエラー！Stringは数字じゃない\\n```\\n\\n**メリット：**\\n- 間違った型を入れるのを防げる\\n- Number系のメソッド（doubleValue など）が使える",
  "java_lesson4_ex3_slide1_title": "? ワイルドカードとは？",
  "java_lesson4_ex3_slide1_content": "# 不明な型を表す\\n\\n**?**（クエスチョンマーク）は「どんな型でもOK」を表す特別な記号です。これを **ワイルドカード** と呼びます。\\n\\n**たとえ話：** トランプのジョーカーのように、どんなカードの代わりにもなれます。\\n\\n```java\\n// どんな型のリストも受け取れるメソッド\\npublic void printList(List<?> list) {\\n    for (Object o : list) {\\n        System.out.println(o);\\n    }\\n}\\n```\\n\\nこのメソッドは `List<String>` でも `List<Integer>` でも受け取れます！",
  "java_lesson4_ex3_slide2_title": "境界付きワイルドカード",
  "java_lesson4_ex3_slide2_content": "# 上限・下限の指定\\n\\nワイルドカードにも制限をつけられます。\\n\\n**上限（じょうげん）を指定：extends**\\n```java\\nList<? extends Number>  // Numberか、その子クラス\\n// Integer, Double などはOK、StringはNG\\n```\\n\\n**下限（かげん）を指定：super**\\n```java\\nList<? super Integer>  // Integerか、その親クラス\\n// Integer, Number, Object などがOK\\n```\\n\\n**覚え方：**\\n- extends → 「〜以下」（Numberから下）\\n- super → 「〜以上」（Integerから上）",
  "java_lesson4_ex4_slide1_title": "Map（マップ）とは？",
  "java_lesson4_ex4_slide1_content": "# キーと値の対応（たいおう）\\n\\n**Map**（マップ＝対応表）は、「キー（名前）」と「値（データ）」のペアを保存できるデータ構造です。\\n\\n**たとえ話：** 電話帳のようなものです。「名前」で検索すると「電話番号」が分かりますよね。それがMapです。\\n\\n```java\\nMap<String, Integer> ages = new HashMap<>();  // 電話帳を作る\\nages.put(\\\"Alice\\\", 25);  // Aliceの年齢は25\\nages.put(\\\"Bob\\\", 30);    // Bobの年齢は30\\n\\nint age = ages.get(\\\"Alice\\\"); // Aliceで検索→25が返る\\n```",
  "java_lesson4_ex5_slide1_title": "entrySet（エントリーセット）",
  "java_lesson4_ex5_slide1_content": "# キーと値のセットを取得\\n\\n**entrySet** を使うと、Mapの全てのペア（キーと値のセット）を順番に取り出せます。\\n\\n**たとえ話：** 電話帳の全ページをめくりながら、「名前と電話番号」を一組ずつ読み上げるイメージです。\\n\\n```java\\nfor (Map.Entry<String, Integer> e : map.entrySet()) {\\n    // getKey()でキー、getValue()で値を取得\\n    System.out.println(e.getKey() + \\\": \\\" + e.getValue());\\n}\\n// Alice: 25\\n// Bob: 30\\n```",
  "java_lesson4_ex5_slide2_title": "forEach メソッド",
  "java_lesson4_ex5_slide2_content": "# Java 8以降の書き方\\n\\nもっと短く書けるforEachメソッドもあります。ラムダ式と組み合わせて使います。\\n\\n```java\\nmap.forEach((key, value) -> {\\n    System.out.println(key + \\\": \\\" + value);\\n});\\n```\\n\\n**何をしているの？**\\n- 「keyとvalueを受け取って、それを表示する」という処理を全ペアに対して実行します\\n\\n**どちらを使う？**\\n- entrySet：古いJavaでも動く\\n- forEach：短くて読みやすい（Java 8以降）",
  "java_lesson4_ex7_slide1_title": "Comparable（コンパラブル）とは？",
  "java_lesson4_ex7_slide1_content": "# 自然順序（しぜんじゅんじょ）の定義\\n\\n**Comparable**（コンパラブル＝比較可能な）を実装すると、オブジェクトに「自然な並び順」を定義できます。\\n\\n**たとえ話：** 数字には「1<2<3」という自然な順番があるように、自分で作ったクラスにも「この順番で並べてね」と教えられます。\\n\\n```java\\nclass Person implements Comparable<Person> {\\n    String name;\\n    public int compareTo(Person other) {\\n        // 名前のあいうえお順で比較\\n        return this.name.compareTo(other.name);\\n    }\\n}\\n```",
  "java_lesson4_ex7_slide2_title": "compareTo のルール",
  "java_lesson4_ex7_slide2_content": "# 戻り値（もどりち）の意味\\n\\n`compareTo` メソッドは、比較結果を数字で返します。\\n\\n**ルール：**\\n- `this < other` → マイナスの数を返す（自分が先）\\n- `this == other` → 0を返す（同じ順番）\\n- `this > other` → プラスの数を返す（相手が先）\\n\\n**例：年齢で比較する場合**\\n```java\\nreturn this.age - other.age;\\n// 25 - 30 = -5 （マイナス→自分が先）\\n// 30 - 30 = 0  （0→同じ）\\n// 35 - 30 = 5  （プラス→相手が先）\\n```",
  "java_lesson4_ex8_slide1_title": "Enum（イーナム）とは？",
  "java_lesson4_ex8_slide1_content": "# 固定の値の集合（しゅうごう）\\n\\n**Enum**（イーナム＝列挙型・れっきょがた）は、「決まった選択肢」を定義するものです。\\n\\n**たとえ話：** 信号機の色は「赤・黄・青」の3つだけですよね。それ以外はありません。Enumはこのように「限られた選択肢」を表します。\\n\\n```java\\nenum Color {  // 色の選択肢を定義\\n    RED, GREEN, BLUE  // 赤、緑、青の3つだけ\\n}\\n\\nColor c = Color.RED;  // 赤を選択\\n```",
  "java_lesson4_ex9_slide1_title": "Queue（キュー）とは？",
  "java_lesson4_ex9_slide1_content": "# 先入れ先出し（FIFO：ファイフォー）\\n\\n**Queue**（キュー＝待ち行列）は、「最初に入れたものが最初に出る」データ構造です。\\n\\n**たとえ話：** 遊園地のアトラクションの行列のようなものです。先に並んだ人が先に乗れますよね。これを**FIFO**（First In, First Out＝先入れ先出し）と言います。\\n\\n```java\\nQueue<String> queue = new LinkedList<>();  // 行列を作る\\nqueue.offer(\\\"A\\\");  // Aが並ぶ\\nqueue.offer(\\\"B\\\");  // Bが並ぶ\\nqueue.poll();      // Aが出る（先に並んだから）\\n```",
  "java_lesson4_ex9_slide2_title": "主なメソッド",
  "java_lesson4_ex9_slide2_content": "# よく使うメソッド\\n\\n**offer（オファー）：列に追加**\\n```java\\noffer(e)  // 列の最後に並ぶ\\n```\\n\\n**poll（ポール）：先頭を取り出す**\\n```java\\npoll()    // 列の先頭から出る（空ならnull）\\n```\\n\\n**peek（ピーク）：先頭を見る（出ない）**\\n```java\\npeek()    // 次は誰？と確認するだけ（列からは出ない）\\n```\\n\\n**覚え方：** 行列に並ぶ(offer)→出る(poll)→確認する(peek)",
  "java_lesson4_ex10_slide1_title": "Deque（デック）とは？",
  "java_lesson4_ex10_slide1_content": "# 両端（りょうたん）から操作できるキュー\\n\\n**Deque**（デック＝Double-Ended Queue）は、先頭からも末尾からも追加・削除ができるキューです。\\n\\n**たとえ話：** 両開きドアのある電車のようなものです。前からも後ろからも乗り降りできます！\\n\\n```java\\nDeque<String> deque = new ArrayDeque<>();  // 両開きキューを作る\\ndeque.addFirst(\\\"A\\\");  // 先頭に追加\\ndeque.addLast(\\\"B\\\");   // 末尾に追加\\n```",
  "java_lesson4_ex10_slide2_title": "スタックとしても使える",
  "java_lesson4_ex10_slide2_content": "# 後入れ先出し（LIFO：ライフォー）\\n\\nDequeは**スタック**としても使えます。「最後に入れたものが最初に出る」構造です。\\n\\n**たとえ話：** お皿を積み重ねたイメージです。最後に置いたお皿が一番上にあるので、最初に取れますよね。\\n\\n```java\\nDeque<Integer> stack = new ArrayDeque<>();\\nstack.push(1);  // 1を積む\\nstack.push(2);  // 2を積む（1の上に）\\nstack.pop();    // 2を取り出す（一番上だから）\\n```\\n\\n**覚え方：**\\n- Queue（キュー）→ FIFO（先入れ先出し）：行列\\n- Stack（スタック）→ LIFO（後入れ先出し）：積み重ね",
  "java_lesson5_ex2_slide1_title": "finally（ファイナリー）とは？",
  "java_lesson5_ex2_slide1_content": "# 必ず実行される処理\\n\\n**finally**（ファイナリー＝最後に）ブロックは、例外が起きても起きなくても**必ず**実行されます。\\n\\n**たとえ話：** 料理が成功しても失敗しても、最後は必ずキッチンを片付けますよね。それがfinallyです。\\n\\n```java\\ntry {\\n    // 処理（成功するかも、失敗するかも）\\n} catch (Exception e) {\\n    // 例外処理（失敗したときだけ）\\n} finally {\\n    // 必ず実行される（成功でも失敗でも！）\\n}\\n```",
  "java_lesson5_ex2_slide2_title": "リソースの解放（かいほう）",
  "java_lesson5_ex2_slide2_content": "# クリーンアップ処理に使う\\n\\nファイルを開いたら閉じる、接続（せつぞく）を切るなど、「後片付け」をfinallyに書きます。\\n\\n**たとえ話：** 本を読み終わったら本棚に戻す、電気を使ったら消す、ということを忘れずにできます。\\n\\n```java\\nFileReader reader = null;\\ntry {\\n    reader = new FileReader(\\\"file.txt\\\");\\n    // ファイルを読む処理\\n} finally {\\n    if (reader != null) reader.close();  // 必ず閉じる！\\n}\\n```\\n\\n**メリット：** エラーが起きても後片付けを忘れません",
  "java_lesson5_ex3_slide1_title": "throws（スローズ）とは？",
  "java_lesson5_ex3_slide1_content": "# 例外を呼び出し元に伝える\\n\\n**throws**（スローズ＝投げる）は、「このメソッドは例外を投げるかもしれません」と宣言（せんげん）するキーワードです。\\n\\n**たとえ話：** 「このボールは爆発するかもしれないので、受け取る人は気をつけてね」と注意書きをつけるようなものです。\\n\\n```java\\npublic void readFile() throws IOException {\\n    // ファイル読み込み処理\\n    // IOException（入出力エラー）が起きる可能性あり！\\n}\\n```",
  "java_lesson5_ex3_slide2_title": "呼び出し側の責任（せきにん）",
  "java_lesson5_ex3_slide2_content": "# キャッチか再スロー（投げ渡し）\\n\\nthrowsがついたメソッドを呼ぶ側は、「キャッチする」か「さらに上に投げる」かを選びます。\\n\\n**方法1：自分でキャッチする**\\n```java\\ntry {\\n    readFile();  // 例外が起きるかも\\n} catch (IOException e) {\\n    // 自分で対処する\\n}\\n```\\n\\n**方法2：さらに上に投げる**\\n```java\\npublic void caller() throws IOException {\\n    readFile();  // 自分は対処せず、呼び出し元に任せる\\n}\\n```\\n\\n**たとえ話：** 問題が起きたら「自分で解決する」か「上司に報告する」かの選択です",
  "java_lesson5_ex4_slide1_title": "カスタム例外（れいがい）",
  "java_lesson5_ex4_slide1_content": "# 独自（どくじ）の例外を定義\\n\\n**Exception** を継承（けいしょう）して、自分だけのオリジナル例外を作れます。\\n\\n**たとえ話：** 標準の例外は「一般的なエラー」ですが、カスタム例外は「このアプリ専用のエラー」です。「年齢がマイナスはおかしい！」という特別なエラーを作れます。\\n\\n```java\\nclass MyException extends Exception {  // Exceptionを継承\\n    public MyException(String msg) {\\n        super(msg);  // 親クラスにメッセージを渡す\\n    }\\n}\\n```",
  "java_lesson5_ex4_slide2_title": "使い方",
  "java_lesson5_ex4_slide2_content": "# throw（スロー）で投げる\\n\\n`throw`（スロー＝投げる）を使って、自分で例外を発生させられます。\\n\\n**コード例：** 年齢がマイナスならエラーにする\\n```java\\nif (age < 0) {\\n    throw new MyException(\\\"年齢は正の数です\\\");\\n}\\n```\\n\\n**何が起きる？**\\n1. 年齢が0より小さいかチェック\\n2. 小さければ例外を「投げる」\\n3. どこかでcatchされるまで上に伝わる\\n\\n**注意：** throw は「投げる」、throws は「投げるかもしれないと宣言」で違います",
  "java_lesson5_ex5_slide1_title": "自動リソース管理（かんり）",
  "java_lesson5_ex5_slide1_content": "# try-with-resources（トライ・ウィズ・リソーシズ）\\n\\nJava 7以降、リソース（ファイルなど）を自動で閉じてくれる便利な書き方ができます。\\n\\n**たとえ話：** 図書館で本を借りると、返却期限が来たら自動で返却される仕組みのようなものです。\\n\\n```java\\ntry (FileReader reader = new FileReader(\\\"file.txt\\\")) {\\n    // reader を使う処理\\n}  // ここで自動で close() が呼ばれる！\\n```\\n\\n`()`（カッコ）の中でリソースを宣言するのがポイントです",
  "java_lesson5_ex5_slide2_title": "メリット",
  "java_lesson5_ex5_slide2_content": "# finally が不要\\n\\n従来は finally で手動で閉じる必要がありましたが、try-with-resources なら自動です。\\n\\n**従来の書き方（長い）**\\n```java\\nFileReader r = null;\\ntry {\\n    r = new FileReader(\\\"file.txt\\\");\\n} finally {\\n    if (r != null) r.close();  // 手動で閉じる\\n}\\n```\\n\\n**try-with-resources（短い！）**\\n```java\\ntry (FileReader r = new FileReader(\\\"file.txt\\\")) {\\n    // 処理\\n}  // 自動で閉じる！\\n```\\n\\n**メリット：** 閉じ忘れがなくなり、コードもシンプルに！",
  "java_lesson5_ex6_slide1_title": "BufferedReader（バッファードリーダー）",
  "java_lesson5_ex6_slide1_content": "# バッファ付き読み込み\\n\\n**BufferedReader** は効率的（こうりつてき）にテキストを読み込むためのクラスです。\\n\\n**たとえ話：** 本を読むとき、1文字ずつ読むより、1行ずつ読む方が速いですよね。BufferedReaderは「1行ずつ」まとめて読めます。\\n\\n```java\\nBufferedReader br = new BufferedReader(\\n    new FileReader(\\\"file.txt\\\")  // ファイルを読む準備\\n);\\nString line = br.readLine();  // 1行読み込む\\n```",
  "java_lesson5_ex6_slide2_title": "全行（ぜんぎょう）読み込み",
  "java_lesson5_ex6_slide2_content": "# ループで読み込み\\n\\nファイルの全部の行を読みたいときは、whileループを使います。\\n\\n```java\\nString line;\\nwhile ((line = br.readLine()) != null) {  // 読めなくなるまで\\n    System.out.println(line);  // 1行ずつ表示\\n}\\n```\\n\\n**何が起きている？**\\n1. `readLine()` で1行読む\\n2. 読めたら表示して、次の行へ\\n3. 読めなくなったら（null）ループ終了\\n\\n**ポイント：** readLine() は行がなくなると null を返します",
  "java_lesson5_ex7_slide1_title": "BufferedWriter（バッファードライター）",
  "java_lesson5_ex7_slide1_content": "# バッファ付き書き込み\\n\\n**BufferedWriter** は効率的にテキストを書き込むためのクラスです。\\n\\n**たとえ話：** 手紙を書くとき、1文字書くたびにポストに入れるより、書き終わってからまとめて送る方が効率的ですよね。BufferedWriterは「まとめて書く」ことで高速になります。\\n\\n```java\\nBufferedWriter bw = new BufferedWriter(\\n    new FileWriter(\\\"file.txt\\\")  // ファイルに書く準備\\n);\\nbw.write(\\\"Hello\\\");  // 文字列を書く\\nbw.close();         // 閉じる（忘れずに！）\\n```",
  "java_lesson5_ex7_slide2_title": "newLine（ニューライン）で改行",
  "java_lesson5_ex7_slide2_content": "# 改行（かいぎょう）を追加\\n\\n`newLine()`を使うと、改行（次の行に移る）を追加できます。\\n\\n```java\\nbw.write(\\\"Line1\\\");  // 1行目を書く\\nbw.newLine();       // 改行！\\nbw.write(\\\"Line2\\\");  // 2行目を書く\\n```\\n\\n**結果のファイル：**\\n```\\nLine1\\nLine2\\n```\\n\\n**ポイント：** write() だけでは改行されません。改行したいときは newLine() を使いましょう",
  "java_lesson5_ex8_slide1_title": "Scanner（スキャナー）とは？",
  "java_lesson5_ex8_slide1_content": "# テキストのパース（解析）\\n\\n**Scanner**（スキャナー＝読み取り機）は、テキストを単語や数字に分けて読み込みます。\\n\\n**たとえ話：** 文章を「スキャン」して、必要な情報を取り出すイメージです。「10 20 30」という文字列から、10、20、30という数字を取り出せます。\\n\\n```java\\nScanner sc = new Scanner(\\\"10 20 30\\\");  // 文字列をスキャン\\nint a = sc.nextInt();  // 最初の数字 → 10\\nint b = sc.nextInt();  // 次の数字 → 20\\n```",
  "java_lesson5_ex8_slide2_title": "様々な読み込み方法",
  "java_lesson5_ex8_slide2_content": "# 便利なメソッド\\n\\n読み込みたいデータの種類によって、使うメソッドが違います。\\n\\n**数字を読む**\\n```java\\nnextInt()    // 整数（1, 2, 3 など）\\nnextDouble() // 小数（1.5, 3.14 など）\\n```\\n\\n**文字を読む**\\n```java\\nnext()       // 単語1つ（空白で区切り）\\nnextLine()   // 1行まるごと\\n```\\n\\n**まだ読めるかチェック**\\n```java\\nhasNext()    // 次のデータがあるか？\\n```\\n\\n**覚え方：** next〇〇 で「次の〇〇を読む」です",
  "java_lesson5_ex9_slide1_title": "NIO2 API（エヌアイオーツー）",
  "java_lesson5_ex9_slide1_content": "# モダンなファイル操作（そうさ）\\n\\nJava 7以降の **Files**（ファイルズ）クラスは、ファイル操作を簡単にする便利なメソッドを提供します。\\n\\n**たとえ話：** 従来のファイル操作は「手動でドアを開け閉め」するイメージでしたが、NIO2は「自動ドア」のように楽に操作できます。\\n\\n```java\\nPath path = Paths.get(\\\"file.txt\\\");  // ファイルのパス（場所）を指定\\nList<String> lines = Files.readAllLines(path);  // 全行を一気に読む！\\n```",
  "java_lesson5_ex9_slide2_title": "便利なメソッド",
  "java_lesson5_ex9_slide2_content": "# Files クラスのメソッド\\n\\nFilesクラスには便利なメソッドがたくさんあります。\\n\\n**読み込み**\\n```java\\nFiles.readAllLines(path)  // 全行をリストで取得\\nFiles.readString(path)    // 全内容を文字列で取得\\n```\\n\\n**書き込み**\\n```java\\nFiles.write(path, lines)  // リストの内容を書き込み\\n```\\n\\n**チェック**\\n```java\\nFiles.exists(path)        // ファイルがあるか確認\\n```\\n\\n**メリット：** 1行で読み書きできて、とても便利！",
  "java_lesson5_ex10_slide1_title": "マルチキャッチ",
  "java_lesson5_ex10_slide1_content": "# 複数（ふくすう）の例外をまとめて\\n\\nJava 7以降、**|**（パイプ記号）を使って複数の例外をまとめてキャッチできます。\\n\\n**たとえ話：** 「りんごかみかんが落ちてきたら拾う」のように、複数の種類をまとめて対処できます。\\n\\n```java\\ntry {\\n    // 処理\\n} catch (IOException | SQLException e) {  // どちらかが起きたら\\n    // 両方の例外を同じように処理\\n}\\n```\\n\\n同じ処理をする例外は、まとめて書くとスッキリします！",
  "java_lesson5_ex10_slide2_title": "個別（こべつ）にキャッチ",
  "java_lesson5_ex10_slide2_content": "# 順番にキャッチ\\n\\n例外の種類ごとに違う処理をしたい場合は、catchを複数書きます。\\n\\n```java\\ntry {\\n    // 処理\\n} catch (FileNotFoundException e) {\\n    // ファイルがない場合の処理\\n} catch (IOException e) {\\n    // その他の入出力エラーの処理\\n}\\n```\\n\\n**大事なルール：** 具体的な例外を先に、一般的な例外を後に書きます。\\n\\n**なぜ？** 先に一般的なものを書くと、具体的なものまでキャッチされてしまい、区別できなくなるからです",
  "c_lesson1_ex1_slide1_title": "C言語とは？",
  "c_lesson1_ex1_slide1_content": "# すべての言語の「お父さん」\\n\\nC言語（シーげんご）は、今から50年以上前に作られたとても歴史（れきし）のあるプログラミング言語です。\\n\\n**身近な例え：**\\nC言語は「プログラミング言語の家系図」でいうと、一番上のご先祖様のような存在です！\\n\\n今のスマホやパソコンを動かしている「OS（オーエス）」という、コンピュータの「脳みそ」のような大事な部分は、ほとんどこのC言語で作られています。\\n\\nまさに、コンピュータ界の「お父さん」のような存在です！",
  "c_lesson1_ex1_slide2_title": "C言語の「きまり文句」",
  "c_lesson1_ex1_slide2_content": "# 最初に書く「おまじない」\\n\\nC言語を動かすには、必ず書かなければいけない「お約束」があります。\\n\\n**1. `#include <stdio.h>`（インクルード・スタンダード・アイオー・エイチ）：**\\n「画面に文字を出す道具」を用意する呪文（じゅもん）です。図書館から本を借りてくるようなイメージです！\\n\\n**2. `int main() { ... }`（イント・メイン）：**\\n「ここからプログラムが始まりますよ！」という合図です。本の「第1章」のようなものです。\\n\\n**実際のコードを見てみましょう：**\\n```c\\n#include <stdio.h>\\nint main() {\\n    printf(\\\"C言語は楽しい！\\\\n\\\");\\n    return 0;\\n}\\n```\\n\\n`printf`（プリントエフ）は「画面に文字を表示してね」という命令です。\\n`return 0`（リターン・ゼロ）は「うまくいきました！」という報告です。\\n\\nこの形を覚えてしまいましょう！",
  "c_lesson1_ex2_slide1_title": "変数（へんすう）とは？",
  "c_lesson1_ex2_slide1_content": "# データを保存する「はこ」\\n\\nプログラミングでは、数字や文字をしまっておく「はこ」を作ることができます。\\nこの「はこ」のことを **変数（へんすう）** と呼びます。\\n\\n**身近な例え：**\\nおもちゃ箱に「ブロック入れ」「ぬいぐるみ入れ」と名前をつけるように、プログラムでも「はこ」に名前をつけて、中身が何かわかるようにしておきます！\\n\\n例えば、「点数」を入れておきたいなら `score` という名前の「はこ」を作ります。",
  "c_lesson1_ex2_slide2_title": "ラベル（型）が必要です",
  "c_lesson1_ex2_slide2_content": "# int（イント）ラベル\\n\\nC言語では、「はこ」を作るとき、「何を入れるか」を先に決めておく必要があります。これを **型（かた）** または **ラベル** と呼びます。\\n\\n**整数（せいすう）**（1, 2, 3 のような小数点のない数字）を入れたいときは、`int`（イント）というラベルを貼ります。\\n\\n**画面に表示するときの約束：**\\n`%d` という記号を使います。これは「ここに数字（Decimal＝デシマル、10進数の意味）が入るよ！」という目印です。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint count = 10;  // 「count」という名前の「はこ」に10を入れる\\nprintf(\\\"%d\\\\n\\\", count);  // countの中身を表示する\\n```\\n=> 10 と表示されます",
  "c_lesson1_ex3_slide1_title": "算数とプログラミング",
  "c_lesson1_ex3_slide1_content": "# 計算はコンピュータの得意技\\n\\nコンピュータの一番の得意なことは「正確（せいかく）で速い計算」です。\\n\\n**身近な例え：**\\n人間が電卓（でんたく）を使って計算するより、コンピュータは何百倍も速く計算できます。しかも、どんなに長い時間計算しても疲（つか）れません！\\n\\nどんなに複雑（ふくざつ）な計算も、プログラミングで指示を出せば一瞬（いっしゅん）で解いてくれます。",
  "c_lesson1_ex3_slide2_title": "計算の記号",
  "c_lesson1_ex3_slide2_content": "# 算数と同じ記号を使います\\n\\nC言語でも、学校の算数と同じような記号を使って計算します。\\n\\n**演算子（えんざんし）の一覧：**\\n- **+** : たし算（足す）\\n- **-** : ひき算（引く）\\n- **\\\\*** : かけ算（かける）※キーボードのアスタリスク\\n- **/** : わり算（わる）※キーボードのスラッシュ\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint x = 10;  // xに10を入れる\\nint y = 20;  // yに20を入れる\\n// x と y をたした答えを表示\\nprintf(\\\"%d\\\\n\\\", x + y);\\n```\\n=> 30 と表示されます（10 + 20 = 30）",
  "c_lesson1_ex4_slide1_title": "あまりを求める",
  "c_lesson1_ex4_slide1_content": "# 割り算の「あまり」を知りたい！\\n\\n算数で「10 ÷ 3 = 3 あまり 1」と習いましたよね。\\n\\n**身近な例え：**\\n10個のクッキーを3人で分けると、1人3個ずつもらえて、1個あまります。この「あまりの1個」だけを知りたいときに使うのが `%`（パーセント）記号です。\\n\\n`%` を使うと、その **あまり** だけを計算してくれます。\\nこれを専門用語で「剰余（じょうよ）」と呼びます。",
  "c_lesson1_ex4_slide2_title": "% の使い方",
  "c_lesson1_ex4_slide2_content": "# あまりを計算してみよう\\n\\n**例1：10を3で割ったあまり**\\n```c\\nprintf(\\\"%d\\\\n\\\", 10 % 3);  // => 1\\n```\\n10 ÷ 3 は「3 あまり 1」なので、「1」が表示されます。\\n\\n**例2：8を2で割ったあまり**\\n```c\\nprintf(\\\"%d\\\\n\\\", 8 % 2);   // => 0\\n```\\n8 ÷ 2 は「4 あまり 0」なので、「0」になります。\\n\\n**ポイント：**\\nあまりが0ということは、きれいに割り切れるということです！\\n「偶数（ぐうすう）かどうか」を調べるときなどに便利です。",
  "c_lesson1_ex5_slide1_title": "中身を増やしたいとき",
  "c_lesson1_ex5_slide1_content": "# はこの中身をパワーアップ\\n\\n「今の点数に10点プラスしたい！」というとき、`+=`（プラスイコール）を使うと便利です。\\n\\n**身近な例え：**\\n貯金箱に500円入っていて、そこに100円を足すようなイメージです。貯金箱の中身が600円になりますよね！\\n\\nこれは「今の数字に足して、そのまま保存する」という合体技です。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint x = 10;   // xに10を入れる\\nx += 5;       // xに5を足して、xに保存（x = x + 5 と同じ意味）\\nprintf(\\\"%d\\\\n\\\", x);  // => 15\\n```\\n\\n`x = x + 5` と書くのと同じ意味ですが、`x += 5` の方が短くて楽に書けます！",
  "c_lesson1_ex5_slide2_title": "-= も使える",
  "c_lesson1_ex5_slide2_content": "# 引き算バージョン\\n\\n`-=`（マイナスイコール）を使えば、「今の数字から引いて保存」ができます。\\n\\n**身近な例え：**\\nおこづかい1000円から300円のお菓子を買うと、残りは700円になりますよね！\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint x = 10;   // xに10を入れる\\nx -= 3;       // xから3を引いて、xに保存（x = x - 3 と同じ意味）\\nprintf(\\\"%d\\\\n\\\", x);  // => 7\\n```\\n\\n**他にもあるよ：**\\n- `*=` : かけ算して保存\\n- `/=` : わり算して保存",
  "c_lesson1_ex6_slide1_title": "文章と変数をドッキング",
  "c_lesson1_ex6_slide1_content": "# 変数の中身を流し込む\\n\\n文章の途中に、変数（はこ）の中身を表示したいときがありますよね。\\n\\n**身近な例え：**\\n「○○さん、こんにちは！」の○○に名前を入れるように、文章の中の特定の場所に数字や文字を入れることができます。\\n\\nC言語では、あらかじめ「ここに数字が入りますよ」という目印（めじるし）を文章の中に置いておきます。この目印が `%d`（パーセント・ディー）です。",
  "c_lesson1_ex6_slide2_title": "%d を使いましょう",
  "c_lesson1_ex6_slide2_content": "# ここにデータが入るよ！\\n\\n`%d`（パーセント・ディー）と書いたところに、後ろに書いた変数の中身が入ります。\\n\\n**身近な例え：**\\n「穴埋（あなう）め問題」と同じです！「今は（　）月です」の（　）に答えを入れるイメージです。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint month = 12;  // monthに12を入れる\\nprintf(\\\"今は %d 月です\\\\n\\\", month);\\n//      ↑ここに month の中身(12)が入る\\n```\\n=> 今は 12 月です\\n\\n**ポイント：**\\n`%d` は整数（せいすう）を入れるときに使います。小数点のある数字には `%f` を使います。",
  "c_lesson1_ex7_slide1_title": "配列（はいれつ）とは？",
  "c_lesson1_ex7_slide1_content": "# データをまとめて整理整頓（せいりせいとん）\\n\\nたくさんのデータを順番に並べておきたいときに使うのが **配列（はいれつ）** です。\\n\\n**身近な例え：**\\nロッカーが横に並んでいるイメージです！1番目のロッカー、2番目のロッカー...というように、順番に並んだ「はこ」の列です。\\n\\n「5教科のテストの点数」のように、関連（かんれん）する数字を一つの名前でまとめて管理（かんり）できます。",
  "c_lesson1_ex8_slide1_title": "条件分岐（じょうけんぶんき）とは？",
  "c_lesson1_ex8_slide1_content": "# プログラムに判断（はんだん）させてみよう\\n\\n日常生活（にちじょうせいかつ）でも「もし〜なら」という判断をしていますよね。\\n\\n**身近な例え：**\\n- 「もし雨が降ったら傘（かさ）をさす」\\n- 「もし晴れたら外で遊ぶ」\\n- 「もしテストで80点以上なら、ごほうびがもらえる」\\n\\nこんなふうに、状況（じょうきょう）によって動きを変えることを **条件分岐（じょうけんぶんき）** と呼びます。\\n\\nプログラムに「もし〜なら、これをしてね」と教えてあげましょう。",
  "c_lesson1_ex8_slide2_title": "もし〜なら（if）",
  "c_lesson1_ex8_slide2_content": "# if（イフ）の使い方\\n\\n`if`（イフ）は英語で「もし」という意味です。\\n\\nC言語では、`if (条件)` のあとに `{ }` 波かっこを書いて、その中に「条件が正しいときにやること」を書きます。\\n\\n**比較に使う記号：**\\n- `>` : より大きい\\n- `<` : より小さい\\n- `>=` : 以上（いじょう）\\n- `<=` : 以下（いか）\\n- `==` : 等しい（等号が2つ！）\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint temp = 35;  // 気温を35度とする\\nif (temp > 30) {  // もし気温が30より大きければ\\n    printf(\\\"暑い！\\\\n\\\");  // 「暑い！」と表示\\n}\\n```\\n\\n気温が30度より高いので、「暑い！」と表示されます。",
  "c_lesson1_ex9_slide1_title": "それ以外の場合は？",
  "c_lesson1_ex9_slide1_content": "# 2つの道を作る\\n\\n「もし〜なら」に当てはまらなかったときの動きも作ってみましょう。\\n\\n**身近な例え：**\\n「もしテストで80点以上なら、ゲームができる。そうでなければ、勉強する。」\\n\\nこのように、条件に当てはまる場合と、当てはまらない場合の2つの道を作ることができます。\\n\\n**else（エルス）** を使うと、「そうじゃなければ、こっちをしてね」という指示が出せます。",
  "c_lesson1_ex9_slide2_title": "そうじゃなければ（else）",
  "c_lesson1_ex9_slide2_content": "# 2つのルート\\n\\n`else`（エルス）は英語で「そうでなければ」という意味です。\\n\\n条件にあてはまらなかったときの動きは `else { }` の中に書きます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint hour = 15;  // 今は15時\\nif (hour < 12) {  // もし12時より前なら\\n    printf(\\\"午前\\\\n\\\");  // 「午前」と表示\\n} else {  // そうでなければ（12時以降なら）\\n    printf(\\\"午後\\\\n\\\");  // 「午後」と表示\\n}\\n```\\n\\n15時は12時以降なので、「午後」と表示されます。\\n\\n**ポイント：**\\n`if` と `else` はセットで使うことで、「どちらか一方」を選べます。",
  "c_lesson1_ex10_slide1_title": "条件を組み合わせる",
  "c_lesson1_ex10_slide1_content": "# もっと細かい条件で\\n\\n**身近な例え：**\\n「映画を見に行くには、お金があって、かつ、時間もないとダメ」\\n「遊園地に行くか、または、映画を見るか、どちらかに決めよう」\\n\\nこのように、2つの条件を組み合わせたいときがあります。\\n\\n- **&&（アンド）**: 「かつ」の意味。両方の条件を満たす必要がある\\n- **||（オア）**: 「または」の意味。どちらか片方でもOK\\n\\nキーボードでは `&` は Shift + 6、`|` は Shift + \\\\ で入力できます。",
  "c_lesson1_ex10_slide2_title": "&& と || の使い方",
  "c_lesson1_ex10_slide2_content": "# 条件の合体技\\n\\n**&&（かつ）の例：**\\n「10歳以上、かつ、20歳未満」→ 両方クリアしないとダメ\\n```c\\nint age = 15;  // 年齢は15歳\\nif (age >= 10 && age < 20) {  // 10以上 かつ 20未満\\n    printf(\\\"10代です\\\\n\\\");  // 両方クリアなので表示される\\n}\\n```\\n\\n**||（または）の例：**\\n「土曜日、または、日曜日なら休み」→ どちらかでOK\\n```c\\nint day = 6;  // 6 = 土曜日\\nif (day == 6 || day == 0) {  // 土曜(6) または 日曜(0)\\n    printf(\\\"休みです\\\\n\\\");\\n}\\n```\\n\\n**ポイント：**\\n`&&` は「両方とも○」のとき実行\\n`||` は「どちらか○」のとき実行",
  "c_lesson1_ex11_slide1_title": "繰り返し（ループ）とは？",
  "c_lesson1_ex11_slide1_content": "# 面倒（めんどう）なことはコンピュータにおまかせ\\n\\n同じ作業を何度も繰り返すのが **ループ（繰り返し）** です。\\n\\n**身近な例え：**\\n「『おはよう』を100回書いてください」と言われたら、人間は大変ですよね。\\nでもコンピュータなら、文句も言わず一瞬（いっしゅん）で100回書いてくれます！\\n\\n100回どころか、1000回、10000回でも、疲（つか）れることなくやってくれます。",
  "c_lesson1_ex11_slide2_title": "くりかえし（for）",
  "c_lesson1_ex11_slide2_content": "# for文の3つのきまり\\n\\n`for`（フォー）文は、「何回繰り返すか」を細かく指定できます。\\n\\n**書き方：**\\n`for (スタート; 続ける条件; 1回ごとの処理)`\\n\\n**実際のコードを見てみましょう：**\\n```c\\nfor (int i = 0; i < 3; i++) {\\n    printf(\\\"ヤッホー\\\\n\\\");\\n}\\n```\\n\\n**それぞれの意味：**\\n1. `int i = 0` → カウンター「i」を0からスタート\\n2. `i < 3` → iが3より小さい間、続ける\\n3. `i++` → 1回終わるごとにiを1増やす\\n\\n**`++` について：**\\n`++`（プラスプラス）は「インクリメント演算子（えんざんし）」といって、「1を足す」という意味です。\\n`i++` は `i = i + 1` と同じ意味です。",
  "c_lesson1_ex12_slide1_title": "構造体（こうぞうたい）とは？",
  "c_lesson1_ex12_slide1_content": "# オリジナルの「はこセット」を作る\\n\\n今まで、数字を入れる「はこ」は1つのデータしか持てませんでした。\\n\\n**身近な例え：**\\n友達のプロフィールカードを想像してください。1枚のカードに「名前」「年齢」「好きな食べ物」など、いろいろな情報がまとまっていますよね。\\n\\n**構造体（こうぞうたい）** を使うと、このように種類（しゅるい）の違うデータをひとまとめにして管理（かんり）できます。\\n\\n自分だけの新しいデータのセット（プロフィールカードのようなもの）を作ることができるのです！",
  "c_lesson1_ex12_slide2_title": "struct（ストラクト）",
  "c_lesson1_ex12_slide2_content": "# 自分だけの型を作る\\n\\n`struct`（ストラクト）は英語で「構造」という意味です。\\n\\n`struct` という言葉を使うと、複数（ふくすう）の変数をまとめた新しい「はこ」の **設計図（せっけいず）** を作れます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\n// 本の情報をまとめる設計図を作る\\nstruct Book {\\n    int price;  // 値段（ねだん）\\n};\\n\\n// 設計図を使って実物の「本」を作る\\nstruct Book b = {500};  // 500円の本\\nprintf(\\\"%d\\\\n\\\", b.price);  // 本の値段を表示\\n```\\n=> 500 と表示されます\\n\\n**ポイント：**\\n`b.price` のように、ドット `.` を使って中のデータにアクセスします。",
  "c_lesson1_ex13_slide1_title": "関数（かんすう）とは？",
  "c_lesson1_ex13_slide1_content": "# オリジナルの技を作ろう\\n\\n何度も使う手順をまとめて名前をつけたものを **関数（かんすう）** と呼びます。\\n\\n**身近な例え：**\\n「朝の準備」という言葉を聞くだけで、「顔を洗う→歯を磨く→着替える」という一連の動作がわかりますよね。\\n\\n関数も同じです！複数の処理をまとめて名前をつけておけば、その名前を呼ぶだけで全部やってくれます。\\n\\n一度作れば、「アレやって！」と名前を呼ぶだけで何度でも実行できる、便利なショートカットのようなものです。",
  "c_lesson1_ex13_slide2_title": "関数を定義しましょう",
  "c_lesson1_ex13_slide2_content": "# 手順をまとめる\\n\\nやりたいことをひとまとめにして、名前をつけることができます。\\n一度作っておけば、呼び出すだけでいつでも動かせます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\n// 「aisatsu」という関数を作る（定義する）\\nvoid aisatsu() {\\n    printf(\\\"ヤッホー\\\\n\\\");\\n}\\n\\n// mainの中で呼ぶ（使う）\\naisatsu();  // これで「ヤッホー」と表示される\\n```\\n\\n**ポイント：**\\n- `void`（ボイド）は「何も返さない」という意味です\\n- 関数名のあとに `()` 丸かっこをつけるのがルールです\\n- `{ }` の中に、やりたい処理を書きます",
  "c_lesson2_ex1_slide1_title": "ポインタとは？",
  "c_lesson2_ex1_slide1_content": "# メモリの住所を覚える変数\\n\\n**ポインタ** は、他の変数がメモリのどこにあるか（住所＝アドレス）を覚えておく特別な変数です。`&` を使うと変数の住所を取得できます。",
  "c_lesson2_ex1_slide2_title": "ポインタの使い方",
  "c_lesson2_ex1_slide2_content": "# * を使って宣言します\\n\\n`int *p` のように `*` をつけるとポインタ変数になります。`&x` で x の住所を取得し、`*p` で住所の中身を見ます。\\n\\n**コード例：**\\n```c\\nint x = 10;\\nint *p = &x;      // p に x の住所を入れる\\nprintf(\\\"%d\\\\n\\\", *p); // p が指す中身を表示 → 10\\n```",
  "c_lesson2_ex2_slide1_title": "間接的に値を変える",
  "c_lesson2_ex2_slide1_content": "# ポインタ経由で書き換え\\n\\nポインタが指す先の値は `*p = 新しい値` で変更できます。これにより、元の変数の中身が変わります。",
  "c_lesson2_ex2_slide2_title": "デリファレンス（参照外し）",
  "c_lesson2_ex2_slide2_content": "# * で中身にアクセス\\n\\n`*p` と書くと「p が指している場所の中身」を意味します。読み取りだけでなく、書き込みもできます。\\n\\n**コード例：**\\n```c\\nint x = 5;\\nint *p = &x;\\n*p = 100;  // x が 100 に変わる\\nprintf(\\\"%d\\\\n\\\", x); // 100\\n```",
  "c_lesson2_ex3_slide1_title": "関数の引数とは？",
  "c_lesson2_ex3_slide1_content": "# 関数に情報を渡す\\n\\n関数を呼ぶときに、外から値を渡すことができます。渡された値は関数の中で使えます。",
  "c_lesson2_ex3_slide2_title": "引数の使い方",
  "c_lesson2_ex3_slide2_content": "# かっこの中に引数を定義\\n\\n関数名の後の () の中に引数を書きます。型と名前を指定します。\\n\\n**コード例：**\\n```c\\nvoid greet(int age) {\\n    printf(\\\"%d歳ですね\\\\n\\\", age);\\n}\\n\\ngreet(10); // 10歳ですね\\n```",
  "c_lesson2_ex4_slide1_title": "戻り値とは？",
  "c_lesson2_ex4_slide1_content": "# 関数から結果を受け取る\\n\\n関数が処理した結果を呼び出し元に返すのが **戻り値** です。`return` を使って値を返します。",
  "c_lesson2_ex4_slide2_title": "return の使い方",
  "c_lesson2_ex4_slide2_content": "# 型を指定して結果を返す\\n\\n関数名の前に戻り値の型を書きます。`void` は戻り値なし、`int` は整数を返します。\\n\\n**コード例：**\\n```c\\nint add(int a, int b) {\\n    return a + b;\\n}\\n\\nint result = add(3, 5); // 8\\n```",
  "c_lesson2_ex6_slide1_title": "C言語の文字列",
  "c_lesson2_ex6_slide1_content": "# 文字の配列 + ヌル終端\\n\\nC言語の文字列は `char` 型の配列で、最後に `\\\\0`（ヌル文字）が入ります。これが文字列の終わりの目印です。",
  "c_lesson2_ex7_slide1_title": "参照渡し風のテクニック",
  "c_lesson2_ex7_slide1_content": "# ポインタで元の値を変える\\n\\nC言語は値渡しですが、ポインタを渡せば関数内から元の変数を変更できます。これを「参照渡し風」と呼びます。",
  "c_lesson2_ex7_slide2_title": "アドレスを引数に",
  "c_lesson2_ex7_slide2_content": "# 関数側でポインタを受け取る\\n\\n関数の引数をポインタにし、呼び出し時に `&` でアドレスを渡します。\\n\\n**コード例：**\\n```c\\nvoid add_ten(int *p) {\\n    *p = *p + 10;\\n}\\n\\nint x = 5;\\nadd_ten(&x);\\nprintf(\\\"%d\\\\n\\\", x); // 15\\n```",
  "c_lesson2_ex8_slide1_title": "動的メモリとは？",
  "c_lesson2_ex8_slide1_content": "# 実行時にメモリを確保\\n\\n配列のサイズを実行時に決めたいときは **動的メモリ確保** を使います。`malloc` 関数でメモリを確保し、使い終わったら `free` で解放します。",
  "c_lesson2_ex8_slide2_title": "malloc と free",
  "c_lesson2_ex8_slide2_content": "# stdlib.h が必要\\n\\n`malloc(サイズ)` でメモリを確保し、ポインタで受け取ります。必ず `free` で解放しましょう。\\n\\n**コード例：**\\n```c\\n#include <stdlib.h>\\nint *p = malloc(sizeof(int));\\n*p = 100;\\nprintf(\\\"%d\\\\n\\\", *p);\\nfree(p);\\n```",
  "c_lesson2_ex9_slide1_title": "構造体とポインタ",
  "c_lesson2_ex9_slide1_content": "# 構造体もアドレスを持つ\\n\\n構造体変数のアドレスをポインタに入れることで、効率的に構造体を扱えます。大きな構造体を関数に渡すときに特に便利です。",
  "c_lesson2_ex9_slide2_title": "アロー演算子 ->",
  "c_lesson2_ex9_slide2_content": "# ポインタからメンバにアクセス\\n\\n構造体ポインタからメンバにアクセスするには `->` を使います。`(*p).x` と `p->x` は同じ意味です。\\n\\n**コード例：**\\n```c\\nstruct Point { int x; int y; };\\nstruct Point pt = {3, 4};\\nstruct Point *p = &pt;\\nprintf(\\\"%d\\\\n\\\", p->x); // 3\\n```",
  "c_lesson2_ex10_slide1_title": "列挙型とは？",
  "c_lesson2_ex10_slide1_content": "# 名前付き定数のグループ\\n\\n**enum（列挙型）** を使うと、関連する値に意味のある名前をつけてまとめられます。コードが読みやすくなります。",
  "c_lesson2_ex10_slide2_title": "enum の使い方",
  "c_lesson2_ex10_slide2_content": "# 値は自動で 0 から割り当て\\n\\nenum で定義した名前には、自動的に 0, 1, 2... と値が割り当てられます。\\n\\n**コード例：**\\n```c\\nenum Color { RED, GREEN, BLUE };\\nenum Color c = GREEN;\\nprintf(\\\"%d\\\\n\\\", c); // 1\\n```",
  "c_lesson3_ex1_slide1_title": "関数ポインタとは？",
  "c_lesson3_ex1_slide1_content": "# 関数を指すポインタ\\n\\n**関数ポインタ** は、関数のアドレスを格納できる変数です。\\n\\n```c\\nint add(int a, int b) { return a + b; }\\n\\n// 関数ポインタの宣言\\nint (*fp)(int, int);\\nfp = add;\\n```",
  "c_lesson3_ex1_slide2_title": "関数ポインタの使い方",
  "c_lesson3_ex1_slide2_content": "# 関数を変数として扱う\\n\\n```c\\nint (*fp)(int, int) = add;\\nint result = fp(2, 3);  // 5\\n```",
  "c_lesson3_ex3_slide1_title": "ビットAND とは？",
  "c_lesson3_ex3_slide1_content": "# 両方が1なら1\\n\\n**&** は、両方のビットが1の場合のみ1になります。\\n\\n```c\\n// 5 = 0101\\n// 3 = 0011\\n// -------\\n// 1 = 0001\\nint result = 5 & 3;  // 1\\n```",
  "c_lesson3_ex3_slide2_title": "使用例：マスク",
  "c_lesson3_ex3_slide2_content": "# 特定ビットの抽出\\n\\n```c\\n// 下位4ビットだけ取得\\nint x = 0xAB;  // 10101011\\nint low4 = x & 0x0F;  // 00001011 = 11\\n```",
  "c_lesson3_ex4_slide1_title": "ビットOR とは？",
  "c_lesson3_ex4_slide1_content": "# どちらかが1なら1\\n\\n**|** は、どちらかのビットが1なら1になります。\\n\\n```c\\n// 5 = 0101\\n// 3 = 0011\\n// -------\\n// 7 = 0111\\nint result = 5 | 3;  // 7\\n```",
  "c_lesson3_ex4_slide2_title": "使用例：フラグ設定",
  "c_lesson3_ex4_slide2_content": "# ビットを立てる\\n\\n```c\\nint flags = 0;\\nflags |= 0x01;  // フラグ1をON\\nflags |= 0x04;  // フラグ3をON\\n// flags = 0x05 (0101)\\n```",
  "c_lesson3_ex5_slide1_title": "シフト演算とは？",
  "c_lesson3_ex5_slide1_content": "# ビットを移動\\n\\n**<<** は左シフト、**>>** は右シフトです。\\n\\n```c\\nint x = 1;     // 0001\\nx << 2;        // 0100 = 4\\nx << 3;        // 1000 = 8\\n```",
  "c_lesson3_ex5_slide2_title": "2の累乗との関係",
  "c_lesson3_ex5_slide2_content": "# 掛け算・割り算の代わり\\n\\n```c\\n// 左シフト = 2倍\\n5 << 1;  // 10\\n\\n// 右シフト = 2で割る\\n8 >> 1;  // 4\\n```",
  "c_lesson3_ex6_slide1_title": "sizeof とは？",
  "c_lesson3_ex6_slide1_content": "# バイトサイズを取得\\n\\n**sizeof** は、型や変数のバイト数を返します。\\n\\n```c\\nprintf(\\\"%zu\\\\n\\\", sizeof(int));    // 4（環境依存）\\nprintf(\\\"%zu\\\\n\\\", sizeof(char));   // 1\\nprintf(\\\"%zu\\\\n\\\", sizeof(double)); // 8\\n```",
  "c_lesson3_ex7_slide1_title": "typedef とは？",
  "c_lesson3_ex7_slide1_content": "# 型に別名を定義\\n\\n**typedef** を使うと、型に新しい名前をつけられます。\\n\\n```c\\ntypedef unsigned int uint;\\ntypedef int* IntPtr;\\n\\nuint x = 10;\\nIntPtr p = &x;\\n```",
  "c_lesson3_ex7_slide2_title": "構造体との組み合わせ",
  "c_lesson3_ex7_slide2_content": "# 構造体を簡潔に\\n\\n```c\\ntypedef struct {\\n    int x;\\n    int y;\\n} Point;\\n\\nPoint p = {10, 20};\\n```",
  "c_lesson3_ex8_slide1_title": "const とポインタ",
  "c_lesson3_ex8_slide1_content": "# 何が const か？\\n\\n```c\\n// 指す先の値が変更不可\\nconst int *p1;\\n\\n// ポインタ自体が変更不可\\nint * const p2;\\n\\n// 両方変更不可\\nconst int * const p3;\\n```",
  "c_lesson3_ex8_slide2_title": "使いどころ",
  "c_lesson3_ex8_slide2_content": "# 安全な関数引数\\n\\n```c\\nvoid print(const char *str) {\\n    // str の中身は変更できない\\n    printf(\\\"%s\\\\n\\\", str);\\n}\\n```",
  "c_lesson3_ex9_slide1_title": "static とは？",
  "c_lesson3_ex9_slide1_content": "# 値を保持する\\n\\n**static** 変数は、関数が終了しても値を保持します。\\n\\n```c\\nvoid count() {\\n    static int n = 0;\\n    n++;\\n    printf(\\\"%d\\\\n\\\", n);\\n}\\n```",
  "c_lesson3_ex9_slide2_title": "呼び出しごとに増加",
  "c_lesson3_ex9_slide2_content": "# カウンタとして使う\\n\\n```c\\ncount();  // 1\\ncount();  // 2\\ncount();  // 3\\n```",
  "c_lesson3_ex10_slide1_title": "マクロとは？",
  "c_lesson3_ex10_slide1_content": "# コンパイル前の置換\\n\\n**#define** でマクロを定義すると、コンパイル前に置換されます。\\n\\n```c\\n#define PI 3.14159\\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\\n```",
  "c_lesson3_ex10_slide2_title": "関数風マクロ",
  "c_lesson3_ex10_slide2_content": "# 引数を取るマクロ\\n\\n```c\\n#define SQUARE(x) ((x) * (x))\\n\\nint result = SQUARE(5);  // 25\\n```",
  "c_lesson4_ex1_slide1_title": "fopen とは？",
  "c_lesson4_ex1_slide1_content": "# ファイルを開く\\n\\n**fopen**（エフオープン）は、ファイルを開くための関数（かんすう）です。\\n\\n**身近な例え：**\\n本を読むとき、まず本棚（ほんだな）から本を取り出しますよね。`fopen` は「本を手に取る」ような操作です。\\n\\n**実際のコードを見てみましょう：**\\n```c\\n// file.txtというファイルを読み込みモードで開く\\nFILE *fp = fopen(\\\"file.txt\\\", \\\"r\\\");\\n\\n// ファイルが開けなかった場合の確認\\nif (fp == NULL) {\\n    printf(\\\"Error!\\\\n\\\");  // エラーを表示\\n}\\n```\\n\\n**ポイント：**\\n- `FILE *fp`（ファイル・ポインタ）は、開いたファイルを指す「目印」です\\n- ファイルが見つからないと `NULL`（ヌル）が返ってきます",
  "c_lesson4_ex1_slide2_title": "モードの種類",
  "c_lesson4_ex1_slide2_content": "# オープンモード\\n\\nファイルを開くときに、「何をしたいか」を指定します。これを**モード**と呼びます。\\n\\n**主なモード一覧：**\\n```c\\n\\\"r\\\"  // Read（読み込み）: ファイルの中身を見る\\n\\\"w\\\"  // Write（書き込み）: 新しく書く（元の内容は消える！）\\n\\\"a\\\"  // Append（追記）: 最後に付け足す\\n\\\"rb\\\" // バイナリ読み込み（画像などに使う）\\n\\\"wb\\\" // バイナリ書き込み\\n```\\n\\n**身近な例え：**\\n- `\\\"r\\\"`: ノートを読むだけ\\n- `\\\"w\\\"`: 新しいノートに書く（古いページは捨てる）\\n- `\\\"a\\\"`: ノートの続きから書く",
  "c_lesson4_ex2_slide1_title": "fclose とは？",
  "c_lesson4_ex2_slide1_content": "# ファイルを閉じる\\n\\n**fclose**（エフクローズ）は、開いたファイルを閉じる関数（かんすう）です。\\n\\n**身近な例え：**\\n本を読み終わったら、本棚に戻しますよね。`fclose` は「本を棚に戻す」ような操作です。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nFILE *fp = fopen(\\\"file.txt\\\", \\\"r\\\");  // ファイルを開く\\n// ファイルを使った処理...\\nfclose(fp);  // 使い終わったら閉じる\\n```\\n\\n**リソース**（コンピュータが使うメモリなど）を解放（かいほう）して、他のプログラムも使えるようにします。",
  "c_lesson4_ex2_slide2_title": "重要性",
  "c_lesson4_ex2_slide2_content": "# 必ず閉じる理由\\n\\n**なぜファイルを閉じないといけないの？**\\n\\n1. **バッファ**（一時的な保存場所）の内容が実際にファイルに書き込まれる\\n2. **メモリ**が解放される（パソコンの負担が減る）\\n3. 他のプログラムがそのファイルを使えるようになる\\n\\n**身近な例え：**\\n使った本を返さないと、他の人が読めません。また、本を持ったままだと手がふさがってしまいますよね。\\n\\n**超重要！**\\n`fopen` したら、必ず `fclose` で閉じましょう！これはプログラマーの大切なマナーです。",
  "c_lesson4_ex3_slide1_title": "fprintf とは？",
  "c_lesson4_ex3_slide1_content": "# フォーマット付き出力（しゅつりょく）\\n\\n**fprintf**（エフプリントエフ）は、`printf` のファイル版です。\\n\\n**身近な例え：**\\n`printf` が「画面にメモを書く」なら、`fprintf` は「ノートにメモを書く」イメージです。\\n\\n**実際のコードを見てみましょう：**\\n```c\\n// ファイルを開く\\nFILE *fp = fopen(\\\"out.txt\\\", \\\"w\\\");\\n\\n// ファイルに書き込む（%sは文字列、%dは数字）\\nfprintf(fp, \\\"Name: %s, Age: %d\\\\n\\\", \\\"Alice\\\", 25);\\n// out.txtに「Name: Alice, Age: 25」と書き込まれる\\n```\\n\\n**ポイント：**\\n最初の引数（ひきすう）にファイルポインタ `fp` を指定します。",
  "c_lesson4_ex3_slide2_title": "printf との違い",
  "c_lesson4_ex3_slide2_content": "# 出力先（しゅつりょくさき）の指定\\n\\n`printf` と `fprintf` の違いは「どこに書くか」です。\\n\\n**比較してみましょう：**\\n```c\\n// 画面（標準出力）に書く\\nprintf(\\\"Hello\\\\n\\\");\\n\\n// ファイルに書く\\nfprintf(fp, \\\"Hello\\\\n\\\");\\n\\n// エラーメッセージ用の出力に書く\\nfprintf(stderr, \\\"Error\\\\n\\\");\\n```\\n\\n**用語解説：**\\n- **標準出力（ひょうじゅんしゅつりょく）**: 普通の画面表示\\n- **stderr（スタンダードエラー）**: エラーメッセージ専用の出力先\\n\\n**身近な例え：**\\n`printf` は「黒板に書く」、`fprintf` は「特定のノートに書く」イメージです。",
  "c_lesson4_ex5_slide1_title": "fseek とは？",
  "c_lesson4_ex5_slide1_content": "# ファイル位置を移動\\n\\n**fseek**（エフシーク）は、ファイルの読み書き位置を移動する関数です。\\n\\n**身近な例え：**\\n本を読むとき、「50ページ目を開いて」と言えばそのページに移動できますよね。`fseek` はファイルの中で「ここから読んで！」と位置を指定できます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\n// 先頭から10バイト目に移動\\nfseek(fp, 10, SEEK_SET);\\n\\n// 今いる場所から5バイト戻る\\nfseek(fp, -5, SEEK_CUR);\\n\\n// ファイルの最後に移動\\nfseek(fp, 0, SEEK_END);\\n```\\n\\n**バイト**とは、データの大きさの単位です。英語の1文字 = 1バイトです。",
  "c_lesson4_ex5_slide2_title": "基準位置",
  "c_lesson4_ex5_slide2_content": "# SEEK定数（ていすう）\\n\\n「どこを基準にして移動するか」を指定する定数があります。\\n\\n**3つの基準位置：**\\n```c\\nSEEK_SET  // ファイルの先頭（一番最初）を基準\\nSEEK_CUR  // 現在いる場所（Current）を基準\\nSEEK_END  // ファイルの末尾（一番最後）を基準\\n```\\n\\n**身近な例え：**\\n- `SEEK_SET`: 「本の最初のページから数えて○ページ目」\\n- `SEEK_CUR`: 「今見ているページから○ページ先」\\n- `SEEK_END`: 「本の最後のページから○ページ戻る」\\n\\n**使用例：**\\n`fseek(fp, 0, SEEK_SET)` → ファイルの先頭に戻る",
  "c_lesson4_ex6_slide1_title": "ftell とは？",
  "c_lesson4_ex6_slide1_content": "# 現在位置を取得（しゅとく）\\n\\n**ftell**（エフテル）は、今ファイルのどこにいるかを教えてくれる関数です。\\n\\n**身近な例え：**\\n本を読んでいて「今何ページ目？」と聞くようなものです。`ftell` は「今、ファイルの先頭から何バイト目にいますよ」と教えてくれます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nlong pos = ftell(fp);  // 現在位置を取得\\nprintf(\\\"Position: %ld\\\\n\\\", pos);  // 何バイト目かを表示\\n```\\n\\n**ポイント：**\\n- 戻り値は `long` 型（大きな数を扱える整数型）\\n- `%ld` で表示します（long型のdecimal）",
  "c_lesson4_ex6_slide2_title": "ファイルサイズの取得",
  "c_lesson4_ex6_slide2_content": "# ファイルの大きさを調べる\\n\\n`ftell` と `fseek` を組み合わせると、ファイルの大きさ（サイズ）を調べることができます。\\n\\n**仕組み：**\\n1. ファイルの最後に移動する\\n2. そこが「先頭から何バイト目か」を調べる → それがファイルサイズ！\\n\\n**実際のコードを見てみましょう：**\\n```c\\nfseek(fp, 0, SEEK_END);   // ファイルの最後に移動\\nlong size = ftell(fp);     // 今いる位置 = ファイルサイズ\\nfseek(fp, 0, SEEK_SET);   // 先頭に戻る\\n```\\n\\n**身近な例え：**\\n本の最後のページを開いて、そのページ番号を見れば、全部で何ページあるかわかりますよね。それと同じです！",
  "c_lesson4_ex7_slide1_title": "enum とは？",
  "c_lesson4_ex7_slide1_content": "# 名前付き定数（めいぜんつきていすう）\\n\\n**enum**（イーナム）は、関連（かんれん）する定数（ていすう）に名前をつける仕組みです。\\n\\n**身近な例え：**\\n曜日（ようび）を考えてみてください。「月曜=1、火曜=2、水曜=3...」と番号で覚えるより、「月曜、火曜、水曜...」と名前で覚えた方がわかりやすいですよね。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nenum Color { RED, GREEN, BLUE };  // 色の定数を定義\\nenum Color c = GREEN;  // c に GREEN を入れる\\n// 実際には c = 1 （0から順番に番号がつく）\\n```\\n\\n**ポイント：**\\n最初の定数は 0、次は 1、その次は 2... と自動で番号がつきます。",
  "c_lesson4_ex7_slide2_title": "値の指定",
  "c_lesson4_ex7_slide2_content": "# 明示的（めいじてき）に値を決める\\n\\n自動で番号をつける代わりに、自分で値を決めることもできます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nenum Status {\\n    OK = 200,        // 成功は200\\n    NOT_FOUND = 404, // 見つからないは404\\n    ERROR = 500      // エラーは500\\n};\\n```\\n\\n**身近な例え：**\\nこれは、Webの世界で使われる「ステータスコード」と同じ番号です。\\n- 200: うまくいった！\\n- 404: ページが見つからない\\n- 500: サーバーでエラーが起きた\\n\\n**メリット：**\\nただの数字より、`OK` や `NOT_FOUND` と書いた方が、何を意味しているかわかりやすいですよね！",
  "c_lesson4_ex8_slide1_title": "union とは？",
  "c_lesson4_ex8_slide1_content": "# メモリを共有（きょうゆう）\\n\\n**union**（ユニオン）は、複数の変数が同じメモリ領域（りょういき）を共有する仕組みです。\\n\\n**身近な例え：**\\n1つの部屋を「リビング」と「寝室」で使い分けるイメージです。同時に両方としては使えませんが、必要に応じて使い方を変えられます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nunion Data {\\n    int i;      // 整数\\n    float f;    // 小数\\n    char c;     // 文字\\n};\\n// サイズは一番大きいメンバと同じ\\n```\\n\\n**ポイント：**\\n`struct`（構造体）は全部のメンバに別々の場所を用意しますが、`union` は同じ場所を共有します。",
  "c_lesson4_ex8_slide2_title": "使い方",
  "c_lesson4_ex8_slide2_content": "# 一度に1つだけ有効（ゆうこう）\\n\\n`union` では、**一度に1つの値しか保存できません**。新しい値を入れると、前の値は上書きされて消えてしまいます。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nunion Data d;\\nd.i = 10;              // 整数として10を入れる\\nprintf(\\\"%d\\\\n\\\", d.i);   // => 10 と表示\\n\\nd.f = 3.14;            // 小数として3.14を入れる\\n// ↑ この時点で d.i の値は上書きされて失われる！\\n```\\n\\n**身近な例え：**\\n黒板に「今日の日付」を書いたあと、消して「明日の予定」を書くようなものです。同時に両方は書けません。\\n\\n**いつ使うの？**\\n「メモリを節約したいとき」や「同じデータを違う型で見たいとき」に使います。",
  "c_lesson4_ex9_slide1_title": "ポインタのポインタ",
  "c_lesson4_ex9_slide1_content": "# ポインタを指すポインタ\\n\\n**二重ポインタ**（にじゅうポインタ）は、ポインタ変数のアドレス（番地）を格納（かくのう）します。\\n\\n**身近な例え：**\\n- ポインタは「住所が書かれたメモ」\\n- 二重ポインタは「そのメモがどこにあるかを示す、別のメモ」\\n\\n友達の家の住所が書かれたメモが、引き出しの中にある。その「引き出し」の場所を指すのが二重ポインタです。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nint x = 10;      // 普通の変数\\nint *p = &x;     // xを指すポインタ\\nint **pp = &p;   // pを指すポインタ（二重ポインタ）\\n```\\n\\n`**pp` で `x` の値（10）にアクセスできます。",
  "c_lesson4_ex9_slide2_title": "使いどころ",
  "c_lesson4_ex9_slide2_content": "# 関数でポインタを変更したいとき\\n\\n関数の中でポインタ自体を変更したいときに二重ポインタを使います。\\n\\n**実際のコードを見てみましょう：**\\n```c\\nvoid allocate(int **pp) {\\n    // ポインタが指す先を変更\\n    *pp = malloc(sizeof(int));\\n}\\n\\nint *p;       // まだどこも指していない\\nallocate(&p); // pにメモリを割り当て\\n```\\n\\n**なぜ二重ポインタが必要？**\\n普通のポインタを渡すと「コピー」が渡されるので、関数の中で変更しても元のポインタは変わりません。\\n二重ポインタを使うと、元のポインタ自体を変更できます。\\n\\n**身近な例え：**\\n「住所メモを新しいメモに書き換えたい」とき、メモの「置き場所」を教えてもらう必要があります。",
  "c_lesson4_ex10_slide1_title": "可変長引数とは？",
  "c_lesson4_ex10_slide1_content": "# 引数（ひきすう）の数が決まっていない関数\\n\\n**可変長引数（かへんちょうひきすう）** を使うと、引数の数が決まっていない関数を作れます。\\n\\n**身近な例え：**\\n`printf` を思い出してください。`printf(\\\"Hello\\\")` のように1つだけの時もあれば、`printf(\\\"%d %d\\\", a, b)` のように複数の時もありますよね。これが可変長引数です！\\n\\n**使い方：**\\n`stdarg.h`（スタンダード・アーギュメント）をインクルードして使います。\\n\\n```c\\n#include <stdarg.h>\\n\\nint sum(int count, ...) {  // ... で「何個でもOK」\\n    va_list args;          // 引数リストを作る\\n    va_start(args, count); // 準備開始\\n    // 処理...\\n    va_end(args);          // 終了\\n}\\n```",
  "c_lesson4_ex10_slide2_title": "va_マクロ",
  "c_lesson4_ex10_slide2_content": "# 引数を1つずつ取り出す\\n\\n可変長引数を扱うための **マクロ**（便利な道具）があります。\\n\\n**3つのマクロ：**\\n```c\\nva_list args;              // 引数リストを入れる変数\\nva_start(args, count);     // 初期化（最後の固定引数を指定）\\nint n = va_arg(args, int); // 1つ取り出す（型を指定）\\nva_end(args);              // 終了処理\\n```\\n\\n**身近な例え：**\\n- `va_list`: 引数を入れた「袋」\\n- `va_start`: 袋を開ける\\n- `va_arg`: 袋から1つ取り出す\\n- `va_end`: 袋を閉じる\\n\\n**ポイント：**\\n`va_arg` で取り出すとき、その引数の**型**（int や double など）を指定する必要があります。"
}